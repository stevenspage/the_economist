<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Library</title>
  <link rel="icon" href="favicon.png" type="image/png" />
  <link rel="shortcut icon" href="favicon.png" type="image/png" />
  <link rel="apple-touch-icon" href="favicon.png" />
  <link rel="stylesheet" href="styles/main.css" />
  <!-- epub.js ç”¨äºå°é¢è§£æï¼ˆæœ¬åœ°çº¯é™æ€å¯ç”¨ï¼‰ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
</head>
<body>
  <div class="hero">
    <div class="wrap">
      <div class="brand">
        <h1>My Library</h1>
        <div class="sub">å¿«é€Ÿæœç´¢ã€æ’åºã€ç»§ç»­é˜…è¯»</div>
      </div>
      <div class="actions">
        <span id="count" class="chip">â€¦</span>
      </div>
    </div>
  </div>


  <div class="container">
    <div class="toolbar">
      <div class="search-container">
        <button id="search-btn" class="btn-view search-btn" title="æœç´¢ä¹¦ç± (æŒ‰ / æˆ– F)">
          <span class="search-icon">ğŸ”</span>
        </button>
        <input id="search" class="input search-input" placeholder="æœç´¢ä¹¦åâ€¦ (æŒ‰ ESC å…³é—­)" style="display:none;" />
      </div>
      <select id="sort" class="select">
        <option value="added-desc">æŒ‰æ·»åŠ æ—¶é—´ (æ–°â†’æ—§)</option>
        <option value="added-asc">æŒ‰æ·»åŠ æ—¶é—´ (æ—§â†’æ–°)</option>
        <option value="name-asc">æŒ‰åç§° Aâ†’Z</option>
        <option value="name-desc" selected>æŒ‰åç§° Zâ†’A</option>
        <option value="recent">æŒ‰æœ€è¿‘é˜…è¯»</option>
      </select>

      <button id="view-toggle" class="btn-view" title="åˆ‡æ¢è§†å›¾">
        <span class="view-icon">âŠ</span>
      </button>
    </div>

    <section>
      <div id="skeleton" class="skeleton-grid" aria-hidden="true"></div>
      <div id="book-grid" class="grid" style="display:none;"></div>
      <div id="empty" class="empty" style="display:none;">ä¹¦åº“ä¸ºç©ºã€‚å°† .epub æ”¾å…¥ ebooks/ å¹¶è¿è¡Œè„šæœ¬åŒæ­¥ã€‚</div>
    </section>
  </div>

  <!-- æ•°æ®æ¥æºè‡´è°¢ -->
  <footer style="text-align: center; padding: 20px; margin-top: 40px; border-top: 1px solid var(--border, #e6e6e6); color: var(--muted, #666); font-size: 0.75rem;">
    <p style="margin: 0;">
      ğŸ“š æœ¬é¡¹ç›®å¤–åˆŠèµ„æºåŸºäº 
      <a href="https://github.com/hehonghui/awesome-english-ebooks" target="_blank" rel="noopener" 
         style="color: var(--primary, #007bff); text-decoration: none; font-weight: 500;">
        hehonghui/awesome-english-ebooks
      </a>
      ï¼Œæ›´å¤šå¤–åˆŠèµ„æºè¯·è®¿é—®åŸé¡¹ç›®ä¸»é¡µã€‚
    </p>
  </footer>

  <script>
    // è§†å›¾æ¨¡å¼è®¾ç½®
    const viewModeKey = 'site:viewMode';

    // è§†å›¾æ¨¡å¼
    let currentViewMode = localStorage.getItem(viewModeKey) || 'cover';
    (function initViewToggle(){
      const viewToggle = document.getElementById('view-toggle');
      const viewIcon = viewToggle.querySelector('.view-icon');
      
      function updateViewIcon() {
        viewIcon.textContent = currentViewMode === 'list' ? 'âŠ' : 'â‰¡';
        viewToggle.title = currentViewMode === 'list' ? 'åˆ‡æ¢åˆ°å°é¢è§†å›¾' : 'åˆ‡æ¢åˆ°åˆ—è¡¨è§†å›¾';
      }
      
      updateViewIcon();
      
      viewToggle.addEventListener('click', ()=>{
        currentViewMode = currentViewMode === 'list' ? 'cover' : 'list';
        localStorage.setItem(viewModeKey, currentViewMode);
        updateViewIcon();
        render();
      });
    })();

    // ä» books_data.json åŠ è½½ä¹¦ç±æ•°æ®
    let bookFiles = [];
    let bookInfo = [];
    
    // åŠ è½½ä¹¦ç±æ•°æ®
    async function loadBookData() {
      try {
        const response = await fetch('books_data.json');
        const data = await response.json();
        
        // æå– EPUB æ–‡ä»¶
        const epubFiles = data.files.filter(file => 
          file.name.toLowerCase().endsWith('.epub')
        );
        
        // è½¬æ¢ä¸º bookFiles æ ¼å¼
        bookFiles = epubFiles.map(file => file.name);
        
        // è½¬æ¢ä¸º bookInfo æ ¼å¼ï¼Œä½¿ç”¨æ–‡ä»¶å¤§å°ä½œä¸ºæ’åºä¾æ®
        bookInfo = epubFiles.map((file, index) => ({
          filename: file.name,
          addTime: Date.now() - (index * 1000), // ä½¿ç”¨ç´¢å¼•åˆ›å»ºæ—¶é—´å·®
          addTimeISO: new Date(Date.now() - (index * 1000)).toISOString(),
          size: file.size,
          downloadUrl: file.download_url
        }));
        
        console.log(`æˆåŠŸåŠ è½½ ${bookFiles.length} æœ¬ç”µå­ä¹¦`);
      } catch (error) {
        console.error('åŠ è½½ä¹¦ç±æ•°æ®å¤±è´¥:', error);
        // å¦‚æœåŠ è½½å¤±è´¥ï¼Œæ˜¾ç¤ºç©ºçŠ¶æ€
        bookFiles = [];
        bookInfo = [];
      }
    }

    const basePath = "./ebooks/";
    // Service Worker æ³¨å†Œï¼ˆéœ€ http/https ç¯å¢ƒï¼Œfile:// æ— æ•ˆï¼‰
    if ('serviceWorker' in navigator && location.protocol !== 'file:') {
      navigator.serviceWorker.register('sw.js').catch(()=>{});
    }
    const gridEl = document.getElementById('book-grid');
    const skeletonEl = document.getElementById('skeleton');
    const emptyEl = document.getElementById('empty');
    const searchEl = document.getElementById('search');
    const sortEl = document.getElementById('sort');
    const countEl = document.getElementById('count');

    function fileNameToTitle(name) { 
      if (!name) return '';
      
      // ç§»é™¤ .epub æ‰©å±•å
      let title = name.replace(/\.epub$/i, '');
      
      // å¤„ç† TheEconomist æ ¼å¼ï¼Œè½¬æ¢ä¸º The Economist
      title = title.replace(/^TheEconomist\./, 'The Economist ');
      
      return title;
    }
    function getLastState(bookPath) {
      try { const raw = localStorage.getItem('reader:lastLocation:' + bookPath); return raw ? JSON.parse(raw) : null; } catch { return null; }
    }
    function fmtPercent(p) { if (p==null || isNaN(p)) return ''; const v = Math.max(0, Math.min(100, Math.round(p*100))); return v + '%'; }

    function renderSkeleton(count = 6) {
      skeletonEl.innerHTML = '';
      for (let i=0;i<count;i++) {
        const card = document.createElement('div'); card.className = 'skeleton-card';
        const row = document.createElement('div'); row.className = 'skeleton-row';
        const th = document.createElement('div'); th.className = 'sk-thumb';
        const box = document.createElement('div'); box.style.flex = '1';
        const l1 = document.createElement('div'); l1.className = 'sk-line w70';
        const l2 = document.createElement('div'); l2.className = 'sk-line w40';
        box.appendChild(l1); box.appendChild(l2);
        row.appendChild(th); row.appendChild(box);
        card.appendChild(row);
        skeletonEl.appendChild(card);
      }
      skeletonEl.style.display = '';
      gridEl.style.display = 'none';
    }

    function clearSkeleton() {
      skeletonEl.style.display = 'none';
      gridEl.style.display = '';
    }

    // è·å–æ–‡ä»¶çš„æ·»åŠ æ—¶é—´
    function getFileAddTime(filename) {
      const fileInfo = bookInfo.find(info => info.filename === filename);
      return fileInfo ? (fileInfo.addTime || 0) : 0;
    }

    function render() {
      const q = (searchEl.value || '').toLowerCase().trim();
      let items = bookFiles.map((f, index) => {
        const fileInfo = bookInfo.find(info => info.filename === f);
        return { 
        title: fileNameToTitle(f), 
        file: f, 
          path: fileInfo?.downloadUrl || (basePath + f), // ä½¿ç”¨ä¸‹è½½é“¾æ¥æˆ–æœ¬åœ°è·¯å¾„
        addedIndex: index, // ç”¨äºæŒ‰æ·»åŠ æ—¶é—´æ’åºï¼ˆå…¼å®¹æ¨¡å¼ï¼‰
          addTime: getFileAddTime(f), // æ–‡ä»¶æ·»åŠ æ—¶é—´
          size: fileInfo?.size || 0 // æ–‡ä»¶å¤§å°
        };
      });
      const total = items.length;
      if (q) items = items.filter(it => it.title.toLowerCase().includes(q));

      const sortBy = sortEl.value;
      if (sortBy === 'name-asc' || sortBy === 'name-desc') {
        items.sort((a,b) => a.title.localeCompare(b.title, 'zh-Hans-CN'));
        if (sortBy === 'name-desc') items.reverse();
      } else if (sortBy === 'recent') {
        items.sort((a,b) => (getLastState(b.path)?.updatedAt||0) - (getLastState(a.path)?.updatedAt||0));
      } else if (sortBy === 'added-desc') {
        // æŒ‰æ·»åŠ æ—¶é—´é™åºï¼ˆä½¿ç”¨æ–‡ä»¶åˆ›å»ºæ—¶é—´ï¼‰
        items.sort((a,b) => {
          if (bookInfo.length > 0 && a.addTime && b.addTime) {
            return b.addTime - a.addTime; // æŒ‰æ–‡ä»¶åˆ›å»ºæ—¶é—´é™åº
          } else {
            return b.addedIndex - a.addedIndex; // å…¼å®¹æ¨¡å¼ï¼šæŒ‰æ·»åŠ ç´¢å¼•é™åº
          }
        });
      } else if (sortBy === 'added-asc') {
        // æŒ‰æ·»åŠ æ—¶é—´å‡åºï¼ˆä½¿ç”¨æ–‡ä»¶åˆ›å»ºæ—¶é—´ï¼‰
        items.sort((a,b) => {
          if (bookInfo.length > 0 && a.addTime && b.addTime) {
            return a.addTime - b.addTime; // æŒ‰æ–‡ä»¶åˆ›å»ºæ—¶é—´å‡åº
          } else {
            return a.addedIndex - b.addedIndex; // å…¼å®¹æ¨¡å¼ï¼šæŒ‰æ·»åŠ ç´¢å¼•å‡åº
          }
        });
      }

      gridEl.className = currentViewMode === 'cover' ? 'cover-grid' : 'grid';
      gridEl.innerHTML = '';
      emptyEl.style.display = items.length ? 'none' : 'block';
      countEl.textContent = `å…± ${total} æœ¬ Â· æ˜¾ç¤º ${items.length} æœ¬`;

      items.forEach(it => {
        const st = getLastState(it.path);
        const hasProgress = st && typeof st.percentage === 'number';
        
        if (currentViewMode === 'cover') {
          const card = document.createElement('div');
          card.className = 'cover-card';
          const link = document.createElement('a');
          link.href = `reader.html?book=${encodeURIComponent(it.path)}`;
          
          const coverImage = document.createElement('div');
          coverImage.className = 'cover-image';
          coverImage.innerHTML = '<div class="fallback">EP</div>';
          
          // ä½¿ç”¨è¾…åŠ©å‡½æ•°åˆ›å»ºä¸‹è½½UI
          const { container: downloadUI } = createDownloadUI();
          card.appendChild(downloadUI);
          
          // ä½¿ç”¨è¾…åŠ©å‡½æ•°å¤„ç†ç‚¹å‡»äº‹ä»¶
          coverImage.addEventListener('click', (e) => handleCoverClick(e, it.path, card));
          
          const coverInfo = document.createElement('div');
          coverInfo.className = 'cover-info';
          
          const coverTitle = document.createElement('div');
          coverTitle.className = 'cover-title';
          coverTitle.textContent = it.title;
          coverTitle.style.cssText = `
            font-weight: 600;
            line-height: 1.3;
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: var(--text);
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            word-break: break-word;
            min-height: 2.6em;
          `;
          
          const coverMeta = document.createElement('div');
          coverMeta.className = 'cover-meta';
          if (hasProgress) {
            const pill = document.createElement('span');
            pill.className = 'cover-pill';
            pill.textContent = fmtPercent(st.percentage);
            coverMeta.appendChild(pill);
          }
          
          const format = document.createElement('span');
          format.textContent = 'ğŸ“– EPUB';
          coverMeta.appendChild(format);
          
          // æ·»åŠ ä¸‹è½½æŒ‰é’®
          const downloadBtn = document.createElement('button');
          downloadBtn.className = 'download-btn';
          downloadBtn.innerHTML = 'â¬‡ï¸ ä¸‹è½½';
          downloadBtn.title = 'ä¸‹è½½ç”µå­ä¹¦åˆ°æœ¬åœ°';
          downloadBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            downloadBook(it.path, it.title);
          });
          coverMeta.appendChild(downloadBtn);
          
          
          coverInfo.appendChild(coverTitle);
          coverInfo.appendChild(coverMeta);
          link.appendChild(coverImage);
          link.appendChild(coverInfo);
          card.appendChild(link);
          gridEl.appendChild(card);
          
          observeCover(it.path, coverImage);
        } else {
          // åˆ—è¡¨è§†å›¾
          const card = document.createElement('div');
          card.className = 'card';
          const linkWrap = document.createElement('a');
          linkWrap.href = `reader.html?book=${encodeURIComponent(it.path)}`;

          const wrap = document.createElement('div');
          wrap.className = 'row';

           const thumb = document.createElement('div'); 
           thumb.className = 'thumb'; 
           thumb.textContent = 'EP';
           
           // ä½¿ç”¨è¾…åŠ©å‡½æ•°åˆ›å»ºä¸‹è½½UI
           const { container: downloadUI } = createDownloadUI();
           card.appendChild(downloadUI);
           
           // ä½¿ç”¨è¾…åŠ©å‡½æ•°å¤„ç†ç‚¹å‡»äº‹ä»¶
           thumb.addEventListener('click', (e) => handleCoverClick(e, it.path, card));

          const content = document.createElement('div'); content.style.flex = '1';
          const title = document.createElement('div'); title.className = 'title'; title.textContent = it.title;
          const meta = document.createElement('div'); meta.className = 'meta';
          if (hasProgress) {
            const pill = document.createElement('span'); pill.className = 'pill'; pill.textContent = 'ç»§ç»­ ' + fmtPercent(st.percentage);
            meta.appendChild(pill);
          }
          
          const format = document.createElement('span');
          format.textContent = 'ğŸ“– EPUB';
          meta.appendChild(format);
          
          // æ·»åŠ ä¸‹è½½æŒ‰é’®
          const downloadBtn = document.createElement('button');
          downloadBtn.className = 'download-btn';
          downloadBtn.innerHTML = 'â¬‡ï¸ ä¸‹è½½';
          downloadBtn.title = 'ä¸‹è½½ç”µå­ä¹¦åˆ°æœ¬åœ°';
          downloadBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            downloadBook(it.path, it.title);
          });
          meta.appendChild(downloadBtn);
          
          
          content.appendChild(title); content.appendChild(meta);
          wrap.appendChild(thumb); wrap.appendChild(content);
          linkWrap.appendChild(wrap);
          card.appendChild(linkWrap);
          gridEl.appendChild(card);
          
          observeCover(it.path, thumb);
        }
      });

      clearSkeleton();
      // åœ¨æ¸²æŸ“å®Œæˆåï¼Œæ£€æŸ¥å¹¶æ›´æ–°å·²ä¸‹è½½ä¹¦ç±çš„UIçŠ¶æ€
      checkDownloadedBooks();
    }

    // æœç´¢æ¡†å±•å¼€/æ”¶èµ·é€»è¾‘
    (function initSearch() {
      const searchBtn = document.getElementById('search-btn');
      const searchInput = document.getElementById('search');
      const toolbar = document.querySelector('.toolbar');
      let isSearchOpen = false;

      function openSearch() {
        if (!isSearchOpen) {
          isSearchOpen = true;
          toolbar.classList.add('search-mode');
          searchInput.style.display = 'block';
          searchInput.focus();
          searchInput.select();
        }
      }

      function closeSearch() {
        if (isSearchOpen && !searchInput.value.trim()) {
          isSearchOpen = false;
          toolbar.classList.remove('search-mode');
          searchInput.style.display = 'none';
        }
      }

      searchBtn.addEventListener('click', (e) => {
        e.preventDefault();
        if (isSearchOpen) {
          searchInput.focus();
        } else {
          openSearch();
        }
      });

      searchInput.addEventListener('blur', () => {
        setTimeout(closeSearch, 100); // å»¶è¿Ÿå…³é—­ï¼Œé¿å…ç‚¹å‡»å…¶ä»–å…ƒç´ æ—¶ç«‹å³å…³é—­
      });

      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          searchInput.value = '';
          closeSearch();
          render(); // æ¸…ç©ºæœç´¢æ—¶é‡æ–°æ¸²æŸ“
        }
      });

      // å¯¼å‡ºå‡½æ•°ä¾›å¤–éƒ¨ä½¿ç”¨
      window.openSearch = openSearch;
    })();

    // å¿«æ·é”®èšç„¦æœç´¢
    document.addEventListener('keydown', (e) => {
      if (e.key === '/' || e.key.toLowerCase() === 'f') {
        e.preventDefault();
        window.openSearch();
      }
    });

    // æ‡’åŠ è½½å°é¢
    const coverObserver = 'IntersectionObserver' in window ? new IntersectionObserver((entries)=>{
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const {path, el} = entry.target.__cover || {};
          if (path && el) loadCover(path, el);
          coverObserver.unobserve(entry.target);
        }
      });
    }, { rootMargin: '100px' }) : null;

    function observeCover(path, el){
      el.__cover = {path, el};
      if (coverObserver) coverObserver.observe(el); else loadCover(path, el);
    }

    // å°é¢ç¼“å­˜å·¥å…·
    const CoverCache = {
      INDEX_KEY: 'cover:index:v1',
      DATA_PREFIX: 'cover:data:v1:',
      TTL_MS: 30 * 24 * 60 * 60 * 1000, // 30 å¤©
      MAX_ENTRIES: 40,

      // å®‰å…¨çš„localStorageæ“ä½œ
      store: {
        get(key) {
          try {
            return localStorage.getItem(key);
          } catch {
            return null;
          }
        },
        set(key, value) {
          try {
            localStorage.setItem(key, value);
            return true;
          } catch {
            return false;
          }
        },
        remove(key) {
          try {
            localStorage.removeItem(key);
            return true;
          } catch {
            return false;
          }
        }
      },

      // è·å–å°é¢æ•°æ®key
      getKey(path) { 
        return this.DATA_PREFIX + path; 
      },

      // è·å–ç´¢å¼•æ•°æ®
      getIndex() {
        const data = this.store.get(this.INDEX_KEY) || '{}';
        try {
          return JSON.parse(data);
        } catch {
          return {};
        }
      },

      // æ›´æ–°ç´¢å¼•æ•°æ®
      setIndex(idx) {
        this.store.set(this.INDEX_KEY, JSON.stringify(idx));
      },

      // è·å–ç¼“å­˜çš„å°é¢
      get(path) {
        const idx = this.getIndex();
        const entry = idx[path];
        if (!entry) return null;

        if ((Date.now() - entry.ts) > this.TTL_MS) {
          this.remove(path);
          return null;
        }

        return this.store.get(this.getKey(path));
      },

      // è®¾ç½®å°é¢ç¼“å­˜
      set(path, dataUrl) {
        if (this.store.set(this.getKey(path), dataUrl)) {
          const idx = this.getIndex();
          idx[path] = { ts: Date.now() };
          this.setIndex(idx);
          this.trim();
          return true;
        }
        return false;
      },

      // ç§»é™¤å°é¢ç¼“å­˜
      remove(path) {
        if (this.store.remove(this.getKey(path))) {
          const idx = this.getIndex();
          delete idx[path];
          this.setIndex(idx);
          return true;
        }
        return false;
      },

      // æ¸…ç†è¿‡æœŸç¼“å­˜
      trim() {
        const idx = this.getIndex();
        const entries = Object.entries(idx)
          .sort((a, b) => b[1].ts - a[1].ts);

        if (entries.length <= this.MAX_ENTRIES) return;

        entries
          .slice(this.MAX_ENTRIES)
          .forEach(([path]) => this.remove(path));
      }
    };

    // æ›¿æ¢åŸæ¥çš„å‡½æ•°è°ƒç”¨
    function getCachedCover(path) {
      return CoverCache.get(path);
    }

    function setCachedCover(path, dataUrl) {
      return CoverCache.set(path, dataUrl);
    }

    function removeCover(path) {
      return CoverCache.remove(path);
    }
    function blobToDataURL(blob){ return new Promise((res)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.readAsDataURL(blob); }); }

    async function loadCover(bookPath, el){
      const cached = getCachedCover(bookPath);
      if (cached) { 
        setCoverImage(el, cached);
        return; 
      }

      // ç›´æ¥ä» epub æ–‡ä»¶æå–å°é¢
      try {
        const book = ePub(bookPath);
        if (typeof book.coverUrl === 'function') {
          const url = await book.coverUrl();
          if (url) {
            setCoverImage(el, url);
            try{
              const meta = await book.loaded.metadata; const coverId = meta && (meta.cover || meta.cover_id || meta['cover-id']);
              if (coverId && book.archive && typeof book.archive.get === 'function') {
                const blob = await book.archive.get(coverId); if (blob) { const dataUrl = await blobToDataURL(blob); setCachedCover(bookPath, dataUrl); }
              }
            }catch{}
            return;
          }
        }
        const meta = await book.loaded.metadata;
        const coverId = meta && (meta.cover || meta.cover_id || meta['cover-id']);
        if (coverId && book && book.archive && typeof book.archive.get === 'function') {
          const blob = await book.archive.get(coverId);
          if (blob) {
            const dataUrl = await blobToDataURL(blob);
            setCoverImage(el, dataUrl);
            setCachedCover(bookPath, dataUrl);
            return;
          }
        }
      } catch(e) { /* å¿½ç•¥ï¼Œä½¿ç”¨ EP å ä½ */ }
    }

    function setCoverImage(el, imageUrl) {
      const isCoverImage = el.classList.contains('cover-image');
      
      if (isCoverImage) {
        const fallback = el.querySelector('.fallback');
        if (fallback) fallback.style.display = 'none';
        
        const img = el.querySelector('img') || document.createElement('img');
        img.src = imageUrl;
        img.alt = 'Book Cover';
        if (!el.contains(img)) el.appendChild(img);
      } else {
        el.classList.add('has-cover'); 
        el.style.backgroundImage = `url('${imageUrl}')`;
      }
    }

     // ä¸‹è½½åŠŸèƒ½
     function startDownload(card, bookPath) {
       const downloadProgress = card.querySelector('.download-progress');
       const downloadLabel = card.querySelector('.download-complete-label');
       const progressFill = downloadProgress.querySelector('.progress-fill');
       const progressText = downloadProgress.querySelector('.progress-text');
       
       downloadProgress.style.display = 'block';
       downloadLabel.style.display = 'none';
       
       let progress = 0;
       const interval = setInterval(() => {
         progress += Math.random() * 15 + 5;
         if (progress >= 100) {
           progress = 100;
           clearInterval(interval);
           
           progressText.textContent = 'ä¸‹è½½å®Œæˆ';
           progressFill.style.width = '100%';
           
           setTimeout(() => {
             downloadProgress.style.display = 'none';
             downloadLabel.style.display = 'block';
             
             const downloadKey = `download:${bookPath}`;
             localStorage.setItem(downloadKey, JSON.stringify({
               completed: true,
               completedAt: Date.now()
             }));
           }, 1000);
         } else {
           progressText.textContent = `ä¸‹è½½ä¸­ ${Math.round(progress)}%`;
           progressFill.style.width = progress + '%';
         }
       }, 200 + Math.random() * 300);
     }
     
     // æ£€æŸ¥å·²ä¸‹è½½çš„ä¹¦ç±
     function checkDownloadedBooks() {
       document.querySelectorAll('.cover-card, .card').forEach(card => {
         const link = card.querySelector('a');
         if (!link?.href.includes('book=')) return;
         
         const bookPath = decodeURIComponent(link.href.split('book=')[1]);
         if (checkDownloadStatus(bookPath)) {
           const label = card.querySelector('.download-complete-label');
           if (label) label.style.display = 'block';
         }
       });
     }
     
     // UI åˆ›å»ºè¾…åŠ©å‡½æ•°
    function createDownloadUI() {
      const container = document.createElement('div');
      
      const progress = document.createElement('div');
      progress.className = 'download-progress';
      progress.style.display = 'none';
      progress.innerHTML = `
        <div class="progress-bar">
          <div class="progress-fill" style="width: 0%"></div>
        </div>
        <span class="progress-text">å‡†å¤‡ä¸‹è½½...</span>
      `;
      
      const label = document.createElement('div');
      label.className = 'download-complete-label';
      label.style.display = 'none';
      label.innerHTML = 'âœ“ å·²ç¼“å­˜';
      
      container.appendChild(progress);
      container.appendChild(label);
      return { container, progress, label };
    }

    // ä¸‹è½½çŠ¶æ€æ£€æŸ¥è¾…åŠ©å‡½æ•°
    function checkDownloadStatus(path) {
      const downloadKey = `download:${path}`;
      const downloadStatus = localStorage.getItem(downloadKey);
      let isDownloaded = false;
      try {
        if (downloadStatus) {
          isDownloaded = JSON.parse(downloadStatus).completed === true;
        }
      } catch (err) { /* å¿½ç•¥æŸåçš„æ•°æ® */ }
      return isDownloaded;
    }

    // ç‚¹å‡»å¤„ç†è¾…åŠ©å‡½æ•°
    function handleCoverClick(e, path, card) {
      if (checkDownloadStatus(path)) {
        return; // å·²ä¸‹è½½ï¼Œå…è®¸æ­£å¸¸è·³è½¬
      }
      e.preventDefault();
      e.stopPropagation();
      startDownload(card, path);
    }

    // ä¸‹è½½ç”µå­ä¹¦å‡½æ•°
    function downloadBook(bookPath, bookTitle) {
      try {
        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const link = document.createElement('a');
        link.href = bookPath;
        link.download = bookTitle + '.epub';
        link.style.display = 'none';
        
        // æ·»åŠ åˆ°DOMå¹¶è§¦å‘ä¸‹è½½
        document.body.appendChild(link);
        link.click();
        
        // æ¸…ç†
        document.body.removeChild(link);
        
        // æ˜¾ç¤ºä¸‹è½½æˆåŠŸæç¤º
        showDownloadNotification('ä¸‹è½½å·²å¼€å§‹', 'success');
        
      } catch (error) {
        console.error('ä¸‹è½½å¤±è´¥:', error);
        showDownloadNotification('ä¸‹è½½å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
      }
    }

    // æ˜¾ç¤ºä¸‹è½½é€šçŸ¥
    function showDownloadNotification(message, type = 'info') {
      // åˆ›å»ºé€šçŸ¥å…ƒç´ 
      const notification = document.createElement('div');
      notification.className = `download-notification ${type}`;
      notification.textContent = message;
      
      // æ·»åŠ æ ·å¼
      Object.assign(notification.style, {
        position: 'fixed',
        top: '20px',
        right: '20px',
        padding: '12px 20px',
        borderRadius: '8px',
        color: 'white',
        fontWeight: '500',
        fontSize: '14px',
        zIndex: '1000',
        boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
        transform: 'translateX(100%)',
        transition: 'transform 0.3s ease'
      });
      
      // æ ¹æ®ç±»å‹è®¾ç½®èƒŒæ™¯è‰²
      if (type === 'success') {
        notification.style.background = 'var(--success)';
      } else if (type === 'error') {
        notification.style.background = '#ef4444';
      } else {
        notification.style.background = 'var(--primary)';
      }
      
      // æ·»åŠ åˆ°é¡µé¢
      document.body.appendChild(notification);
      
      // æ˜¾ç¤ºåŠ¨ç”»
      setTimeout(() => {
        notification.style.transform = 'translateX(0)';
      }, 100);
      
      // è‡ªåŠ¨éšè—
      setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
          if (notification.parentNode) {
            document.body.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }

    // æ·»åŠ é˜²æŠ–å‡½æ•°
    function debounce(fn, delay) {
      let timer;
      return function (...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    // ä½¿ç”¨é˜²æŠ–å¤„ç†æœç´¢
    searchEl.addEventListener('input', debounce(render, 300));
    sortEl.addEventListener('change', render);
    renderSkeleton(6);
     
    // åˆå§‹åŠ è½½å’Œæ¸²æŸ“
    async function initialize() {
      await loadBookData();
      render();
    }
    
    // å¼€å§‹åˆå§‹åŒ–
    initialize();
  </script>
</body>
</html>
