<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>é˜…è¯»ç”µå­ä¹¦</title>
  <link rel="icon" href="favicon.png" type="image/png" />
  <link rel="shortcut icon" href="favicon.png" type="image/png" />
  <link rel="apple-touch-icon" href="favicon.png" />
  <link rel="stylesheet" href="styles/reader.css" />
  <style>
    .loading-status {
      margin-top: 12px;
      font-size: 14px;
      color: var(--muted, #888);
      text-align: center;
    }
  </style>
  <!-- JSZip åº“ - å¤šä¸ªå¤‡ç”¨ CDN -->
  <script>
    (function loadJSZip() {
      const jszipCDNs = [
        'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js',
        'https://unpkg.com/jszip@3.1.5/dist/jszip.min.js',
        'https://cdn.jsdelivr.net/npm/jszip@3.1.5/dist/jszip.min.js',
        'scripts/jszip.min.js', 
        'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js'
      ];
      
      
      function tryLoadJSZip(index = 0) {
        if (index >= jszipCDNs.length) {
          console.error('æ‰€æœ‰ JSZip CDN éƒ½åŠ è½½å¤±è´¥');
          return;
        }
        
        const script = document.createElement('script');
        script.src = jszipCDNs[index];
        script.onload = () => {
          console.log('JSZip åŠ è½½æˆåŠŸ:', jszipCDNs[index]);
          loadEPUBjs(); // JSZip åŠ è½½æˆåŠŸååŠ è½½ EPUB.js
        };
        script.onerror = () => {
          console.warn('JSZip CDN åŠ è½½å¤±è´¥:', jszipCDNs[index]);
          tryLoadJSZip(index + 1); // å°è¯•ä¸‹ä¸€ä¸ª CDN
        };
        document.head.appendChild(script);
      }
      
      function loadEPUBjs() {
        const epubCDNs = [
          'https://unpkg.com/epubjs/dist/epub.min.js',
          'https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js',
          'scripts/epub.min.js', 
          'https://unpkg.com/epubjs/dist/epub.min.js',  
        ];
        
        function tryLoadEPUBjs(index = 0) {
          if (index >= epubCDNs.length) {
            console.error('æ‰€æœ‰ EPUB.js CDN éƒ½åŠ è½½å¤±è´¥');
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').textContent = 'EPUB.js åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–åˆ·æ–°é¡µé¢é‡è¯•ã€‚';
            document.getElementById('reader-card').style.display = 'none';
            return;
          }
          
          const script = document.createElement('script');
          script.src = epubCDNs[index];
          script.onload = () => {
            console.log('EPUB.js åŠ è½½æˆåŠŸ:', epubCDNs[index]);
            // åº“åŠ è½½å®Œæˆåï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥ç›´æ¥åˆå§‹åŒ–
            if (typeof ePub !== 'undefined') {
              console.log('EPUB.js åº“å·²å‡†å¤‡å°±ç»ª');
            }
          };
          script.onerror = () => {
            console.warn('EPUB.js CDN åŠ è½½å¤±è´¥:', epubCDNs[index]);
            tryLoadEPUBjs(index + 1); // å°è¯•ä¸‹ä¸€ä¸ª CDN
          };
          document.head.appendChild(script);
        }
        
        tryLoadEPUBjs();
      }
      
      // å¼€å§‹åŠ è½½ JSZip
      tryLoadJSZip();
    })();
  </script>
</head>
<body>
  <div class="container collapsed" id="layout-root">
    
    <!-- NOTE: .topbar å…ƒç´ å·²è¢«ç§»åŠ¨åˆ°ä¸‹æ–¹çš„ #info-card å†…éƒ¨ -->

    <!-- ä¿¡æ¯å¡ (æ–¹æ¡ˆ C) -->
    <div id="info-card">
      <div class="line1">
        <button class="info-back" id="info-back-btn" title="è¿”å›ä¸Šä¸€é¡µ">â†</button>
        <button id="toc-quick-btn" class="info-toc" title="ç›®å½•">
          <span style="display:block; line-height:0;">
            <span style="display:block; width:16px; height:2px; background:#888; margin:3px 0; border-radius:2px;"></span>
            <span style="display:block; width:16px; height:2px; background:#888; margin:3px 0; border-radius:2px;"></span>
            <span style="display:block; width:16px; height:2px; background:#888; margin:3px 0; border-radius:2px;"></span>
          </span>
        </button>
        <button id="topbar-toggle" class="info-toggle" title="é¡¶æ ">â‹¯</button>
                 <span class="name" id="info-name">â€”</span>
         <button class="download-btn" id="download-btn" title="ä¸‹è½½ç”µå­ä¹¦åˆ°æœ¬åœ°">â¬‡</button>
      </div>

      <!-- MODIFIED: .topbar ç§»åŠ¨åˆ°è¿™é‡Œï¼Œä½œä¸º #info-card çš„å­å…ƒç´  -->
      <div class="topbar">
        <div class="left">
          <button class="back icon-btn" id="topbar-back-btn" title="è¿”å›ä¸Šä¸€é¡µ">â†</button>
          <div class="meta title-ellipsis" id="book-meta" title="">æ­£åœ¨åŠ è½½â€¦</div>
        </div>
        <div class="right controls">
          <div id="cover-mini" class="btn" style="display:none; gap:6px; align-items:center;" title="å°é¢ä¸ä¿¡æ¯ (I)">
            <span class="cover-box"></span>
            å°é¢
          </div>
          <button id="bm-btn" class="btn" title="ä¹¦ç­¾ (B)">ğŸ”– ä¹¦ç­¾</button>
          <button id="add-bm" class="btn" title="æ·»åŠ å½“å‰é¡µä¸ºä¹¦ç­¾">ï¼‹ ä¹¦ç­¾</button>
          <div class="sep"></div>
          <button id="font-dec" class="btn" title="å‡å°å­—å· (Alt+-)">A-</button>
          <button id="font-inc" class="btn" title="å¢å¤§å­—å· (Alt+=)">A+</button>
          <select id="theme" class="select" title="é˜…è¯»ä¸»é¢˜">
            <option value="day">æ—¥é—´</option>
            <option value="sepia">æŠ¤çœ¼</option>
            <option value="gray">ç°è‰²</option>
            <option value="night">å¤œé—´</option>
          </select>
          <button id="toggle-site-theme" class="btn" title="ç«™ç‚¹ä¸»é¢˜ (Alt+D)">ğŸŒ“</button>
          <button id="help-btn" class="btn" title="å¸®åŠ© (H)">â“</button>
        </div>
      </div>
    </div>

    <div class="progress">
      <input id="slider" class="range" type="range" min="0" max="1000" step="1" value="0" />
      <div id="percent" class="percent">0%</div>
    </div>

         <!-- é€‰åŒºæ“ä½œï¼ˆé«˜äº®/å¤åˆ¶/æ·»åŠ æ³¨é‡Šï¼‰ -->
     <div id="selbar" class="controls">
       <span>æ ‡æ³¨ï¼š</span>
       <button data-color="hl-yellow" class="hl-chip hl-yellow">é»„è‰²</button>
       <button data-color="hl-green" class="hl-chip hl-green">ç»¿è‰²</button>
       <button data-color="hl-pink" class="hl-chip hl-pink">ç²‰è‰²</button>
       <div class="sep"></div>
       <button id="copy-selection" class="btn">å¤åˆ¶é€‰ä¸­</button>
       <button id="clear-highlights" class="btn">æ¸…é™¤æœ¬ç« æ ‡æ³¨</button>
     </div>

     <!-- ä¸‹è½½çŠ¶æ€æ˜¾ç¤º -->
     <div id="download-status" class="card" style="display: none; margin-bottom: 16px; padding: 20px; text-align: center;">
       <div id="download-cover" style="width: 200px; height: 280px; margin: 0 auto 20px; background: linear-gradient(135deg, #8B4513 0%, #A0522D 50%, #CD853F 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: bold;">
         <span id="cover-text">EP</span>
       </div>
       <h3 id="download-title" style="margin: 0 0 16px; color: var(--text);">æ­£åœ¨åŠ è½½ç”µå­ä¹¦...</h3>
       <div id="download-progress-container" style="width: 100%; max-width: 400px; margin: 0 auto;">
         <div id="download-progress-bar" style="width: 100%; height: 8px; background: rgba(0,0,0,0.1); border-radius: 4px; overflow: hidden; margin-bottom: 12px;">
           <div id="download-progress-fill" style="width: 0%; height: 100%; background: #10b981; border-radius: 4px; transition: width 0.3s ease; position: relative;"></div>
         </div>
         <div id="download-progress-text" style="color: var(--muted); font-size: 14px;">å‡†å¤‡ä¸‹è½½...</div>
       </div>
     </div>

     <div class="card" id="reader-card">
      <div id="viewer-container">
        <div id="viewer"></div>
        <div id="reader-skeleton" aria-hidden="true">
          <div class="loading-content">
            <div class="loading-indicator">æ­£åœ¨åŠ è½½ç”µå­ä¹¦ï¼Œè¯·ç¨å€™â€¦</div>
            <div class="loading-progress-bar">
              <div class="loading-progress-fill"></div>
            </div>
            <div id="loading-status-text" class="loading-status">æ­£åœ¨åˆå§‹åŒ–...</div>
          </div>
        </div>
        <div id="nav">
          <div id="prev">â€¹</div>
          <div id="next">â€º</div>
        </div>
      </div>
    </div>

    <div id="error" class="error"></div>

    <!-- ç›®å½•æŠ½å±‰ -->
    <aside id="drawer-toc" class="drawer">
      <h3>ç›®å½•</h3>
      <ul id="toc" class="toc-list"></ul>
    </aside>

    <!-- ä¹¦ç­¾æŠ½å±‰ -->
    <aside id="drawer-bm" class="drawer">
      <h3>æˆ‘çš„ä¹¦ç­¾</h3>
      <ul id="bm-list" class="bm-list"></ul>
      <div class="muted">ç‚¹å‡»ä¹¦ç­¾å¯è·³è½¬ï¼Œæˆ–åˆ é™¤ã€‚</div>

      <h3 style="margin-top:12px;">å…¨æ–‡æœç´¢</h3>
      <div class="controls" style="padding:8px;">
        <input id="fulltext-input" class="select" placeholder="è¾“å…¥å…³é”®è¯å¹¶å›è½¦â€¦" />
      </div>
      <ul id="search-results"></ul>
    </aside>

    <!-- ä¿¡æ¯æŠ½å±‰åœ¨ä¸Šæ–¹å·²å®šä¹‰ -->

    <!-- é®ç½©ï¼šç‚¹å‡»å¯å…³é—­æŠ½å±‰ -->
    <div id="overlay"></div>

    <!-- å°é¢ä¸å…ƒæ•°æ®æŠ½å±‰ -->
    <aside id="drawer-info" class="drawer">
      <h3>å°é¢ä¸ä¿¡æ¯</h3>
      <img id="info-cover" class="cover-large" alt="å°é¢é¢„è§ˆ"/>
      <dl id="info-meta" class="meta-table"></dl>
    </aside>
  </div>

  <script>
    // ç«™ç‚¹ä¸»é¢˜ï¼šä¸é¦–é¡µä¿æŒä¸€è‡´
    (function initSiteTheme(){
      const key = 'site:theme';
      const saved = localStorage.getItem(key);
      if (saved) document.body.classList.toggle('dark', saved === 'dark');
      else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) document.body.classList.add('dark');
      const btn = document.getElementById('toggle-site-theme');
      if (btn) {
        btn.addEventListener('click', ()=>{
          const dark = !document.body.classList.contains('dark');
          document.body.classList.toggle('dark', dark);
          localStorage.setItem(key, dark ? 'dark' : 'light');
        });
      }
    })();

    function getQueryParam(name) {
      const url = new URL(window.location.href);
      const value = url.searchParams.get(name);
      return value ? decodeURIComponent(value) : null;
    }

    const bookPath = getQueryParam('book');
    const errorEl = document.getElementById('error');
    const metaEl = document.getElementById('book-meta');
    const percentEl = document.getElementById('percent');
    const sliderEl = document.getElementById('slider');

    const drawerToc = document.getElementById('drawer-toc');
    const drawerBm = document.getElementById('drawer-bm');
    const drawerInfo = document.getElementById('drawer-info');
    const tocList = document.getElementById('toc');
    const bmList = document.getElementById('bm-list');
    const infoCoverEl = document.getElementById('info-cover');
    const infoMetaEl = document.getElementById('info-meta');

    const storageKeys = {
      location: (p) => 'reader:lastLocation:' + p,
      font: (p) => 'reader:fontSize:' + p,
      theme: (p) => 'reader:theme:' + p,
      bookmarks: (p) => 'reader:bookmarks:' + p,
    };

    function safeLoad(key, fallback=null) {
      try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; } catch { return fallback; }
    }
    function safeSave(key, value) {
      try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
    }

    let book, rendition, locationsReady = false;

    if (!bookPath) {
      errorEl.style.display = 'block';
      errorEl.textContent = 'æœªæŒ‡å®šè¦é˜…è¯»çš„ä¹¦ç±ã€‚è¯·ä»é¦–é¡µé€‰æ‹©ä¸€æœ¬ä¹¦ã€‚';
      document.getElementById('reader-card').style.display = 'none';
    } else {
      // æ£€æŸ¥ä¸‹è½½çŠ¶æ€
      const downloadKey = `download:${bookPath}`;
      const downloadStatus = localStorage.getItem(downloadKey);
      const isDownloaded = downloadStatus && JSON.parse(downloadStatus).completed;
      
      // å¦‚æœæœªä¸‹è½½ï¼Œæ˜¾ç¤ºä¸‹è½½ç•Œé¢
      if (!isDownloaded) {
        showDownloadInterface();
        startDownloadProcess();
      } else {
        // å·²ä¸‹è½½ï¼Œç›´æ¥åŠ è½½ç”µå­ä¹¦
        loadEbook();
      }
      
      function showDownloadInterface() {
        document.getElementById('download-status').style.display = 'block';
        document.getElementById('reader-card').style.display = 'none';
        
        // è®¾ç½®ä¹¦å
        const fileName = bookPath.split('/').pop().replace('.epub', '');
        document.getElementById('download-title').textContent = fileName;
      }
      
      function startDownloadProcess() {
        // å°è¯•åŠ è½½å°é¢
        loadCoverForDownload();
        
        // æ¨¡æ‹Ÿä¸‹è½½è¿›åº¦
        let progress = 0;
        const progressFill = document.getElementById('download-progress-fill');
        const progressText = document.getElementById('download-progress-text');
        
        const interval = setInterval(() => {
          progress += Math.random() * 15 + 5; // éšæœºå¢åŠ 5-20%
          if (progress >= 100) {
            progress = 100;
            clearInterval(interval);
            
            // ä¸‹è½½å®Œæˆ
            progressText.textContent = 'ä¸‹è½½å®Œæˆï¼æ­£åœ¨æ‰“å¼€ç”µå­ä¹¦...';
            progressFill.style.width = '100%';
            
            // ä¿å­˜ä¸‹è½½çŠ¶æ€
            localStorage.setItem(downloadKey, JSON.stringify({
              completed: true,
              completedAt: Date.now()
            }));
            
            // å»¶è¿Ÿåéšè—ä¸‹è½½ç•Œé¢ï¼Œæ˜¾ç¤ºé˜…è¯»å™¨
            setTimeout(() => {
              document.getElementById('download-status').style.display = 'none';
              document.getElementById('reader-card').style.display = 'block';
              loadEbook();
            }, 1500);
          } else {
            progressText.textContent = `ä¸‹è½½ä¸­ ${Math.round(progress)}%`;
            progressFill.style.width = progress + '%';
          }
        }, 200 + Math.random() * 300); // éšæœºé—´éš”200-500ms
      }
      
      async function loadCoverForDownload() {
        try {
          // ç®€å•æ£€æŸ¥ï¼šå¦‚æœ ePub å‡½æ•°ä¸å­˜åœ¨ï¼Œç­‰å¾…ä¸€ä¸‹å†è¯•
          if (typeof ePub === 'undefined') {
            setTimeout(loadCoverForDownload, 100);
            return;
          }
          
          const book = ePub(bookPath);
          const coverEl = document.getElementById('download-cover');
          const coverText = document.getElementById('cover-text');
          
          // ä¼˜å…ˆå°è¯•å®˜æ–¹ API
          if (typeof book.coverUrl === 'function') {
            const url = await book.coverUrl();
            if (url) {
              coverEl.style.backgroundImage = `url('${url}')`;
              coverText.style.display = 'none';
              return;
            }
          }
          
          // é€€åŒ–ï¼šä» metadata.cover è·å–èµ„æº
          const meta = await book.loaded.metadata;
          const coverId = meta && (meta.cover || meta.cover_id || meta['cover-id']);
          if (coverId && book.archive && typeof book.archive.get === 'function') {
            const blob = await book.archive.get(coverId);
            if (blob) {
              const dataUrl = await blobToDataURL(blob);
              coverEl.style.backgroundImage = `url('${dataUrl}')`;
              coverText.style.display = 'none';
              return;
            }
          }
        } catch(e) { 
          // å¿½ç•¥é”™è¯¯ï¼Œä½¿ç”¨é»˜è®¤å°é¢
        }
      }
      
      function blobToDataURL(blob) {
        return new Promise((res) => {
          const r = new FileReader();
          r.onload = () => res(r.result);
          r.readAsDataURL(blob);
        });
      }
      
      // å…¨å±€å˜é‡ï¼Œä¾›æ‰€æœ‰å‡½æ•°ä½¿ç”¨
      
      function loadEbook() {
        // ç®€å•æ£€æŸ¥ï¼šå¦‚æœ ePub å‡½æ•°ä¸å­˜åœ¨ï¼Œç­‰å¾…ä¸€ä¸‹å†è¯•
        if (typeof ePub === 'undefined') {
          setTimeout(loadEbook, 100);
          return;
        }
        
        let currentFont = safeLoad(storageKeys.font(bookPath), 100) || 100;
        const storedTheme = safeLoad(storageKeys.theme(bookPath), null);
        let currentTheme = storedTheme || 'gray';

        const skeleton = document.getElementById('reader-skeleton');
        const progressFill = skeleton.querySelector('.loading-progress-fill');

        function updateLoadingProgress(percentage) {
          if (progressFill) {
            progressFill.style.width = `${percentage}%`;
          }
        }

        try {
          updateLoadingProgress(0);
          if (skeleton) skeleton.classList.add('visible');
          
          book = ePub(bookPath);
          updateLoadingProgress(15);

          rendition = book.renderTo('viewer', { width: '100%', height: '100%' });
          updateLoadingProgress(30);

        // è‡ªé€‚åº”é«˜åº¦ï¼šè®©é˜…è¯»åŒºåŸŸå¡«æ»¡å‰©ä½™è§†å£ï¼Œé¿å…åº•ç«¯ç•™ç™½
        const viewerContainer = document.getElementById('viewer-container');
        function resizeViewer(){
          try {
            const rect = viewerContainer.getBoundingClientRect();
            const gap = 16; // é¡µé¢åº•éƒ¨é¢„ç•™
            const h = Math.max(320, Math.floor(window.innerHeight - rect.top - gap));
            viewerContainer.style.height = h + 'px';
          } catch {}
        }
        window.addEventListener('resize', resizeViewer);
        // åˆæ¬¡ä¸å¼‚æ­¥æ¸²æŸ“åå¤šæ¬¡æ ¡å‡†
        setTimeout(resizeViewer, 0);

        // ä¸»é¢˜ & å­—ä½“
        rendition.themes.register('day', {
          body: { background: '#ffffff !important', color: '#222222 !important' },
          '::selection': { background: '#cce5ff' }
        });
        rendition.themes.register('sepia', {
          body: { background: '#f4ecd8 !important', color: '#5b4636 !important' }
        });
        rendition.themes.register('gray', {
          body: { background: '#F5F5F5 !important', color: '#333333 !important' }
        });
        rendition.themes.register('night', {
          body: { background: '#0e0f12 !important', color: '#e2e2e2 !important' },
          a: { color: '#7ab6ff !important' }
        });
        rendition.themes.fontSize(currentFont + '%');
        rendition.themes.select(currentTheme);

        // åŠ è½½ + éª¨æ¶
        const savedLoc = safeLoad(storageKeys.location(bookPath));
        const displayPromise = savedLoc?.cfi 
          ? rendition.display(savedLoc.cfi) 
          : rendition.display();
        
        displayPromise.catch(() => {
          // å¦‚æœCFIåŠ è½½å¤±è´¥ï¼Œå°è¯•æ— å‚æ•°display
          return rendition.display();
        }).finally(() => { 
          updateLoadingProgress(100);
          setTimeout(() => {
            if (skeleton) skeleton.classList.remove('visible'); 
          }, 300);
        });

        // å…ƒæ•°æ®
        book.loaded.metadata.then(meta => {
          updateLoadingProgress(40);
          const title = meta?.title || 'æœªå‘½åä¹¦ç±';
          const author = meta?.creator || meta?.author || '';
          metaEl.textContent = author ? `${title} â€” ${author}` : title;
          metaEl.title = title + (author ? ` â€” ${author}` : '');
          document.title = title + ' | é˜…è¯»ç”µå­ä¹¦';
          // æ›´æ–°ä¿¡æ¯å¡
          const nameEl = document.getElementById('info-name');
          if (nameEl) {
            // ç»„åˆæ˜¾ç¤ºä¹¦åå’Œä½œè€…
            const displayText = author ? `${title}(${author})` : title;
            const fullText = author ? `${title}(${author})` : title;
            
            nameEl.textContent = displayText;
            nameEl.title = fullText; // æ‚¬åœæ—¶æ˜¾ç¤ºå®Œæ•´å†…å®¹
          }
        }).catch(() => { 
          metaEl.textContent = bookPath.split('/').pop(); 
          metaEl.title = metaEl.textContent; 
          
          // é”™è¯¯æƒ…å†µä¸‹ä¹Ÿæ›´æ–°é¡¶æ æ ‡é¢˜
          const nameEl = document.getElementById('info-name');
          if (nameEl) {
            const fileName = bookPath.split('/').pop();
            nameEl.textContent = fileName;
            nameEl.title = fileName;
          }
        });

        // å°é¢ç¼©ç•¥ï¼ˆé˜…è¯»é¡µé¡¶æ ï¼‰
        (async () => {
          const mini = document.getElementById('cover-mini');
          const box = mini ? mini.querySelector('.cover-box') : null;
          if (!mini || !box) return;
          try {
            await book.ready; // ç¡®ä¿æ‰“åŒ…ä¿¡æ¯å¯ç”¨
            // 1) ä¼˜å…ˆä½¿ç”¨ API
            if (typeof book.coverUrl === 'function') {
              const url = await book.coverUrl();
              if (url) {
                box.style.backgroundImage = `url('${url}')`;
                const infoCoverEl = document.getElementById('info-cover');
                if (infoCoverEl) infoCoverEl.src = url;
                mini.style.display = 'inline-flex';
                try { const md = await book.loaded.metadata; fillInfoMeta(md); } catch {}
                return;
              }
            }
            // 2) EPUB3: manifest properties="cover-image"
            const packaging = book.packaging;
            let coverHref = null;
            if (packaging && packaging.manifest) {
              for (const id in packaging.manifest) {
                const it = packaging.manifest[id];
                const props = (it.properties || '').toString();
                if (props.includes('cover-image')) { coverHref = it.href; break; }
              }
              // 3) EPUB2: metadata.cover æŒ‡å‘ manifest id
              if (!coverHref && packaging.metadata && packaging.metadata.cover) {
                const id = packaging.metadata.cover;
                const it = packaging.manifest[id];
                if (it && it.href) coverHref = it.href;
              }
            }
            if (coverHref && book.archive && typeof book.archive.get === 'function') {
              const blob = await book.archive.get(coverHref);
              if (blob) {
                const url = URL.createObjectURL(blob);
                box.style.backgroundImage = `url('${url}')`;
                const infoCoverEl = document.getElementById('info-cover');
                if (infoCoverEl) infoCoverEl.src = url;
                mini.style.display = 'inline-flex';
                try { const md = await book.loaded.metadata; fillInfoMeta(md); } catch {}
                return;
              }
            }
          } catch {/* å¿½ç•¥ */}
        })();

        function fillInfoMeta(md){
          const infoMetaEl = document.getElementById('info-meta');
          if (!infoMetaEl || !md) return;
          infoMetaEl.innerHTML = '';
          const rows = [
            ['æ ‡é¢˜', md.title],
            ['ä½œè€…', md.creator || md.author],
            ['å‡ºç‰ˆç¤¾', md.publisher],
            ['è¯­è¨€', md.language],
            ['å‡ºç‰ˆæ—¶é—´', md.published || md.date],
            ['æ ‡è¯†ç¬¦', md.identifier],
          ].filter(([,v]) => !!v);
          for (const [k,v] of rows){
            const dt = document.createElement('dt'); dt.textContent = k;
            const dd = document.createElement('dd'); dd.textContent = Array.isArray(v) ? v.join(', ') : String(v);
            infoMetaEl.appendChild(dt); infoMetaEl.appendChild(dd);
          }
        }

        // ç›®å½•
        book.loaded.navigation.then(({ toc }) => {
          updateLoadingProgress(60);
          renderTOC(toc || []);
        }).catch(() => { /* å¿½ç•¥ */ });

        // ç”Ÿæˆ locations ç”¨äºè¿›åº¦
        book.ready.then(() => book.locations.generate(1600)).then(() => {
          updateLoadingProgress(85);
          locationsReady = true;
          const loc = rendition.currentLocation();
          updateProgress(loc);
        }).catch(() => { locationsReady = false; });

        // äº‹ä»¶ï¼šç¿»é¡µ
        document.getElementById('prev').addEventListener('click', () => rendition.prev());
        document.getElementById('next').addEventListener('click', () => rendition.next());
        document.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowLeft') rendition.prev();
          if (e.key === 'ArrowRight') rendition.next();
          if (e.key.toLowerCase() === 'i') document.getElementById('cover-mini').click();
          if ((e.altKey && (e.key === '-' || e.key === '_'))) document.getElementById('font-dec').click();
          if ((e.altKey && (e.key === '=' || e.key === '+'))) document.getElementById('font-inc').click();
          if (e.key.toLowerCase() === 't') document.getElementById('toc-quick-btn').click();
          if (e.key.toLowerCase() === 'b') document.getElementById('bm-btn').click();
          if (e.key.toLowerCase() === 'h') document.getElementById('help-btn').click();
          if (e.altKey && (e.key.toLowerCase() === 'd')) document.getElementById('toggle-site-theme').click();
        });

        // äº‹ä»¶ï¼šä½ç½®å˜æ›´ -> æ›´æ–°è¿›åº¦ & ä¿å­˜
        rendition.on('relocated', (location) => {
          updateProgress(location);
          // ä¿å­˜æœ€åé˜…è¯»ä½ç½®
          safeSave(storageKeys.location(bookPath), {
            cfi: location?.start?.cfi || location?.end?.cfi || null,
            percentage: getPercentageFromLocation(location),
            updatedAt: Date.now()
          });
          const pct = getPercentageFromLocation(location);
          const prog = document.getElementById('info-progress');
          if (prog && (pct || pct===0)) prog.textContent = `è¿›åº¦ ${Math.round(pct*100)}%`;
        });

        // å­—ä½“
        document.getElementById('font-inc').addEventListener('click', () => {
          currentFont = Math.min(180, currentFont + 10);
          rendition.themes.fontSize(currentFont + '%');
          safeSave(storageKeys.font(bookPath), currentFont);
        });
        document.getElementById('font-dec').addEventListener('click', () => {
          currentFont = Math.max(80, currentFont - 10);
          rendition.themes.fontSize(currentFont + '%');
          safeSave(storageKeys.font(bookPath), currentFont);
        });

        // ä¸»é¢˜
        const themeSelect = document.getElementById('theme');
        themeSelect.value = currentTheme;
        themeSelect.addEventListener('change', () => {
          currentTheme = themeSelect.value;
          rendition.themes.select(currentTheme);
          // å¼ºåˆ¶åˆ·æ–°å½“å‰è§†å›¾ï¼Œé¿å…ä¸»é¢˜è¢«ä¹¦å†…æ ·å¼è¦†ç›–æˆ–å»¶è¿Ÿåº”ç”¨
          const loc = rendition.currentLocation();
          if (loc?.start?.cfi) rendition.display(loc.start.cfi);
          safeSave(storageKeys.theme(bookPath), currentTheme);
        });

        // è®¾ç½®æ ¹å®¹å™¨æ ·å¼
        const root = document.getElementById('layout-root');

        // æŠ˜å /å±•å¼€é¡¶æ 
        const toggleBtn = document.getElementById('topbar-toggle');
        const COLLAPSE_KEY = 'reader:topbar:collapsed';
        if (toggleBtn) {
          toggleBtn.addEventListener('click', ()=>{
            const collapsed = root.classList.toggle('collapsed');
            localStorage.setItem(COLLAPSE_KEY, String(collapsed));
          });
        }

        // ç‚¹å‡»é¡µé¢è‡ªåŠ¨æ”¶èµ·é¡¶æ ï¼ˆæ’é™¤é¡¶æ /ä¿¡æ¯å¡/æŠ½å±‰/å¸®åŠ©å¼¹çª—åŒºåŸŸï¼‰
        function collapseTopbar(){
          if (!root.classList.contains('collapsed')) {
            root.classList.add('collapsed');
            localStorage.setItem(COLLAPSE_KEY, 'true');
          }
        }
        
        document.addEventListener('click', (e)=>{
          const t = e.target;
          if (t.closest('.topbar') || t.closest('#info-card') || t.closest('.drawer') || t.closest('#help-modal')) return;
          collapseTopbar();
        }, { capture: true });
        // æ”¶èµ·é¡¶æ ï¼šå†…å®¹åŒºç‚¹å‡»ï¼ˆiframe å†…ï¼‰ & ç§»åŠ¨ç«¯æ»‘åŠ¨ç¿»é¡µ
        rendition.on('rendered', (_section, view) => {
          try { 
            view.document.addEventListener('click', collapseTopbar, { capture: true }); 

            // æ»‘åŠ¨ç¿»é¡µé€»è¾‘
            let touchstartX = 0;
            let touchendX = 0;
            let touchstartY = 0;
            let touchendY = 0;
            const swipeThreshold = 50; // æœ€å°æ»‘åŠ¨è·ç¦»
            const swipeYThreshold = 100; // Yè½´æœ€å¤§å®¹å¿æ»‘åŠ¨è·ç¦»

            view.document.addEventListener('touchstart', e => {
              touchstartX = e.changedTouches[0].screenX;
              touchstartY = e.changedTouches[0].screenY;
            }, { passive: true });

            view.document.addEventListener('touchend', e => {
              touchendX = e.changedTouches[0].screenX;
              touchendY = e.changedTouches[0].screenY;
              
              const deltaX = touchendX - touchstartX;
              const deltaY = touchendY - touchstartY;

              // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„æ°´å¹³æ»‘åŠ¨
              if (Math.abs(deltaX) > swipeThreshold && Math.abs(deltaY) < swipeYThreshold) {
                if (deltaX < 0) { // å‘å·¦æ»‘
                  rendition.next();
                } else { // å‘å³æ»‘
                  rendition.prev();
                }
              }
            }, { passive: true });

            // é¼ æ ‡æ»šè½®ç¿»é¡µé€»è¾‘
            let wheelTimeout = null;
            const wheelThreshold = 50; // æ»šè½®æ»šåŠ¨é˜ˆå€¼
            let wheelDelta = 0;

            view.document.addEventListener('wheel', e => {
              // é˜»æ­¢é»˜è®¤æ»šåŠ¨è¡Œä¸º
              e.preventDefault();
              
              // ç´¯ç§¯æ»šè½®å¢é‡
              wheelDelta += e.deltaY;
              
              // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
              if (wheelTimeout) {
                clearTimeout(wheelTimeout);
              }
              
              // è®¾ç½®å»¶è¿Ÿæ‰§è¡Œï¼Œé¿å…å¿«é€Ÿæ»šåŠ¨æ—¶é¢‘ç¹ç¿»é¡µ
              wheelTimeout = setTimeout(() => {
                if (Math.abs(wheelDelta) >= wheelThreshold) {
                  if (wheelDelta > 0) {
                    // å‘ä¸‹æ»šåŠ¨ï¼Œç¿»åˆ°ä¸‹ä¸€é¡µ
                    rendition.next();
                  } else {
                    // å‘ä¸Šæ»šåŠ¨ï¼Œç¿»åˆ°ä¸Šä¸€é¡µ
                    rendition.prev();
                  }
                  // é‡ç½®æ»šè½®å¢é‡
                  wheelDelta = 0;
                }
              }, 150); // 150ms å»¶è¿Ÿï¼Œå¹³è¡¡å“åº”æ€§å’Œç¨³å®šæ€§
            }, { passive: false });

          } catch {}
        });
        // é»˜è®¤ä¸å†å¼ºåˆ¶è·Ÿéšç«™ç‚¹ä¸»é¢˜ï¼Œé¿å…è¦†ç›–ç”¨æˆ·é€‰æ‹©

        // è¿›åº¦æ»‘å—
        sliderEl.addEventListener('input', (e) => {
          const pct = (Number(e.target.value) || 0) / 1000;
          percentEl.textContent = Math.round(pct * 100) + '%';
        });
        sliderEl.addEventListener('change', (e) => {
          if (!locationsReady) return;
          const pct = (Number(e.target.value) || 0) / 1000;
          try {
            const cfi = book.locations.cfiFromPercentage(pct);
            if (cfi) rendition.display(cfi);
          } catch {}
        });

        // ç›®å½•æŠ½å±‰ & ä¹¦ç­¾æŠ½å±‰ & ä¿¡æ¯æŠ½å±‰
        const overlay = document.getElementById('overlay');
        function openDrawer(which){
          drawerToc.classList.toggle('open', which==='toc');
          drawerBm.classList.toggle('open', which==='bm');
          drawerInfo.classList.toggle('open', which==='info');
          const anyOpen = which==='toc' || which==='bm' || which==='info';
          overlay.style.display = anyOpen ? 'block' : 'none';
        }
        function closeDrawers(){ openDrawer(null); }

        // è¿”å›æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        function handleBackClick() {
          if (window.history.length > 1) {
            window.history.back();
          } else {
            // å¦‚æœæ²¡æœ‰å†å²è®°å½•ï¼Œå›é€€åˆ°ä¹¦åº“
            window.location.href = 'index.html';
          }
        }
        
        document.getElementById('info-back-btn').addEventListener('click', handleBackClick);
        document.getElementById('topbar-back-btn').addEventListener('click', handleBackClick);

        // å¿«æ·ç›®å½•æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        document.getElementById('toc-quick-btn').addEventListener('click', () => {
          openDrawer(drawerToc.classList.contains('open') ? null : 'toc');
        });
        document.getElementById('bm-btn').addEventListener('click', () => {
          openDrawer(drawerBm.classList.contains('open') ? null : 'bm');
        });
        document.getElementById('cover-mini').addEventListener('click', () => {
          openDrawer(drawerInfo.classList.contains('open') ? null : 'info');
        });
        overlay.addEventListener('click', closeDrawers);
        // ESC å…³é—­æŠ½å±‰
        document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeDrawers(); });

        // æ·»åŠ ä¹¦ç­¾
        document.getElementById('add-bm').addEventListener('click', () => {
          const loc = rendition.currentLocation();
          const cfi = loc?.start?.cfi || loc?.end?.cfi;
          if (!cfi) return;
          const pct = getPercentageFromLocation(loc);
          const tocItem = findTocItemForCfi(book, loc?.start?.cfi);
          const label = (tocItem?.label || 'å½“å‰ä½ç½®') + ' Â· ' + Math.round((pct || 0) * 100) + '%';
          const list = safeLoad(storageKeys.bookmarks(bookPath), []);
          // å»é‡
          if (!list.some(b => b.cfi === cfi)) {
            list.push({ cfi, label, createdAt: Date.now() });
            safeSave(storageKeys.bookmarks(bookPath), list);
            renderBookmarks(list);
            drawerBm.classList.add('open');
          }
        });

                 // é¦–æ¬¡æ¸²æŸ“ä¹¦ç­¾
         renderBookmarks(safeLoad(storageKeys.bookmarks(bookPath), []));
         
         // ä¸‹è½½æŒ‰é’®åŠŸèƒ½
         const downloadBtn = document.getElementById('download-btn');
         if (downloadBtn) {
           downloadBtn.addEventListener('click', async () => {
             try {
               // æ˜¾ç¤ºä¸‹è½½ä¸­çŠ¶æ€
               downloadBtn.textContent = 'â³';
               downloadBtn.disabled = true;
               
               // è·å–ç”µå­ä¹¦æ•°æ® - ä½¿ç”¨æ­£ç¡®çš„æ–¹æ³•
               let bookData;
               if (book.archive && typeof book.archive.get === 'function') {
                 // å¦‚æœ archive.get æ–¹æ³•å­˜åœ¨ï¼Œä½¿ç”¨å®ƒ
                 bookData = await book.archive.get();
               } else if (book.archive && book.archive.url) {
                 // å¦‚æœ archive.url å­˜åœ¨ï¼Œç›´æ¥ä½¿ç”¨
                 bookData = book.archive.url;
               } else {
                 // å°è¯•ä»åŸå§‹è·¯å¾„è·å–
                 const response = await fetch(bookPath);
                 if (!response.ok) {
                   throw new Error('æ— æ³•è·å–ç”µå­ä¹¦æ•°æ®');
                 }
                 bookData = await response.blob();
               }
               
               if (!bookData) {
                 throw new Error('æ— æ³•è·å–ç”µå­ä¹¦æ•°æ®');
               }
               
               // åˆ›å»ºä¸‹è½½é“¾æ¥
               let blob;
               if (bookData instanceof Blob) {
                 blob = bookData;
               } else if (typeof bookData === 'string') {
                 // å¦‚æœæ˜¯ URLï¼Œéœ€è¦å…ˆè·å–æ•°æ®
                 const response = await fetch(bookData);
                 blob = await response.blob();
               } else {
                 throw new Error('ä¸æ”¯æŒçš„ç”µå­ä¹¦æ•°æ®æ ¼å¼');
               }
               
               const url = URL.createObjectURL(blob);
               const a = document.createElement('a');
               a.href = url;
               a.download = bookPath.split('/').pop() || 'book.epub';
               document.body.appendChild(a);
               a.click();
               document.body.removeChild(a);
               
               // æ¸…ç†URLå¯¹è±¡
               URL.revokeObjectURL(url);
               
               // æ¢å¤æŒ‰é’®çŠ¶æ€
               downloadBtn.textContent = 'âœ…';
               setTimeout(() => {
                 downloadBtn.textContent = 'â¬‡';
                 downloadBtn.disabled = false;
               }, 2000);
               
             } catch (error) {
               console.error('ä¸‹è½½å¤±è´¥:', error);
               downloadBtn.textContent = 'âŒ';
               setTimeout(() => {
                 downloadBtn.textContent = 'â¬‡';
                 downloadBtn.disabled = false;
               }, 2000);
             }
           });
         }

      } catch (err) {
        errorEl.style.display = 'block';
        errorEl.textContent = 'åŠ è½½ç”µå­ä¹¦å¤±è´¥ï¼š' + (err?.message || err);
        document.getElementById('reader-card').style.display = 'none';
      }
    }

    // Service Worker æ³¨å†Œï¼ˆéœ€ http/https ç¯å¢ƒï¼Œfile:// æ— æ•ˆï¼‰
    // ç”¨äºéƒ¨ç½²â€œè‡ªæ€å¼â€workerï¼Œæ¸…ç†æ—§çš„worker
    if ('serviceWorker' in navigator && location.protocol !== 'file:') {
      navigator.serviceWorker.register('sw.js').catch((err) => {
        console.error('Service Worker registration failed:', err);
      });
    }

    // è¾…åŠ©å‡½æ•°å®šä¹‰
    function renderTOC(toc) {
        tocList.innerHTML = '';
        if (!toc || !toc.length) {
          const li = document.createElement('li');
          li.className = 'toc-item muted';
          li.textContent = 'æ— ç›®å½•';
          tocList.appendChild(li);
          return;
        }
        const flat = flattenToc(toc);
        flat.forEach(item => {
          const li = document.createElement('li');
          li.className = 'toc-item';
          li.style.paddingLeft = (item.depth * 12 + 6) + 'px';
          li.textContent = item.label || item.href;
          li.title = item.label || item.href;
          li.addEventListener('click', () => {
            rendition.display(item.href);
            drawerToc.classList.remove('open');
          });
          tocList.appendChild(li);
        });
      }

      function flattenToc(nodes, depth=0, out=[]) {
        (nodes || []).forEach(n => {
          out.push({ label: n.label, href: n.href, depth });
          if (n.subitems && n.subitems.length) flattenToc(n.subitems, depth+1, out);
        });
        return out;
      }

      function renderBookmarks(list) {
        bmList.innerHTML = '';
        if (!list.length) {
          const li = document.createElement('li');
          li.className = 'bm-item muted';
          li.textContent = 'æš‚æ— ä¹¦ç­¾';
          bmList.appendChild(li);
          return;
        }
        list.forEach((b, idx) => {
          const li = document.createElement('li');
          li.className = 'bm-item';
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.justifyContent = 'space-between';
          row.style.gap = '8px';
          const title = document.createElement('div');
          title.textContent = b.label || ('ä¹¦ç­¾ ' + (idx+1));
          const actions = document.createElement('div');
          actions.className = 'bm-actions';
          const go = document.createElement('button'); go.className = 'btn'; go.textContent = 'å‰å¾€';
          const del = document.createElement('button'); del.className = 'btn'; del.textContent = 'åˆ é™¤';
          go.addEventListener('click', () => { rendition.display(b.cfi); drawerBm.classList.remove('open'); });
          del.addEventListener('click', () => {
            const arr = safeLoad(storageKeys.bookmarks(bookPath), []);
            const next = arr.filter(x => x.cfi !== b.cfi);
            safeSave(storageKeys.bookmarks(bookPath), next);
            renderBookmarks(next);
          });
          actions.appendChild(go); actions.appendChild(del);
          row.appendChild(title); row.appendChild(actions);
          li.appendChild(row);
          bmList.appendChild(li);
        });
      }

      function getPercentageFromLocation(location) {
        try {
          if (!location) return 0;
          const cfi = location?.start?.cfi || location?.end?.cfi;
          if (!cfi || !book.locations) return 0;
          if (!locationsReady) return 0;
          return book.locations.percentageFromCfi(cfi) || 0;
        } catch { return 0; }
      }

      function updateProgress(location) {
        if (!locationsReady || !location || !location.start) return;

        try {
          const cfi = location.start.cfi;
          const currentPage = book.locations.locationFromCfi(cfi);
          const totalPages = book.locations.total;
          
          if (currentPage > 0 && totalPages) {
            percentEl.textContent = `${currentPage} / ${totalPages}`;
          } else if (totalPages) {
            percentEl.textContent = `å…± ${totalPages} é¡µ`;
          } else {
            const pct = getPercentageFromLocation(location);
            percentEl.textContent = Math.round(pct * 100) + '%';
          }
          
          const pct = getPercentageFromLocation(location);
          if (pct || pct === 0) {
            sliderEl.value = Math.round(pct * 1000);
          }
        } catch (e) {
          // Fallback to percentage if page calculation fails
          const pct = getPercentageFromLocation(location);
          percentEl.textContent = Math.round(pct * 100) + '%';
        }
      }

      function findTocItemForCfi(book, cfi) {
        // ç®€åŒ–å®ç°ï¼šè¿”å›å½“å‰å¯è§†ç« èŠ‚åï¼ˆå¦‚æœå¯å¾—ï¼‰
        try {
          if (!cfi) return null;
          const nav = book.navigation || book.loaded?.navigation?.value;
          if (!nav || !nav.toc) return null;
          const flat = flattenToc(nav.toc);
          // æœ€ç®€å•ç­–ç•¥ï¼šæ ¹æ® href ç‰‡æ®µåŒ¹é…å½“å‰ spine hrefï¼ˆepub.js æœªæä¾›ç›´æ¥ cfi -> href çš„åŒæ­¥APIï¼‰
          const loc = rendition.currentLocation();
          const href = loc?.start?.href;
          if (!href) return null;
          return flat.find(i => (i.href || '').split('#')[0] === href.split('#')[0]) || null;
        } catch { return null; }
      }
    }
  </script>
  </script>

  <!-- å¸®åŠ©å¼¹çª— -->
  <div id="help-modal" class="modal" aria-modal="true" role="dialog">
    <div class="modal-card">
      <h3>å¿«æ·é”®ä¸æŠ€å·§</h3>
      <div>
        <p><span class="kbd">â†</span> / <span class="kbd">â†’</span> ç¿»é¡µ Â· é¼ æ ‡æ»šè½®ä¸Šä¸‹æ»šåŠ¨ç¿»é¡µ</p>
        <p><span class="kbd">Alt</span> + <span class="kbd">-</span> / <span class="kbd">Alt</span> + <span class="kbd">=</span> è°ƒæ•´å­—å·</p>
        <p><span class="kbd">T</span> æ‰“å¼€/å…³é—­ç›®å½• Â· <span class="kbd">B</span> æ‰“å¼€/å…³é—­ä¹¦ç­¾</p>
        <p><span class="kbd">H</span> æ‰“å¼€/å…³é—­å¸®åŠ© Â· <span class="kbd">Alt</span> + <span class="kbd">D</span> åˆ‡æ¢ç«™ç‚¹ä¸»é¢˜</p>
        <p>æ‹–åŠ¨è¿›åº¦æ¡å¯å¿«é€Ÿå®šä½ Â· é¡¶æ é‡‡ç”¨æ¯›ç»ç’ƒæ•ˆæœå¢å¼ºå¯è¯»æ€§</p>
      </div>
      <div style="margin-top:10px; display:flex; justify-content:flex-end; gap:8px;">
        <button id="help-close" class="btn">å…³é—­</button>
      </div>
    </div>
  </div>

  <script>
    (function helpModalInit(){
      const modal = document.getElementById('help-modal');
      const openBtn = document.getElementById('help-btn');
      const closeBtn = document.getElementById('help-close');
      const toggle = () => modal.classList.toggle('open');
      if (openBtn) openBtn.addEventListener('click', toggle);
      if (closeBtn) closeBtn.addEventListener('click', toggle);
      modal.addEventListener('click', (e) => { if (e.target === modal) toggle(); });
    })();
  </script>
</body>
</html>