<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>阅读电子书</title>
  <link rel="icon" href="favicon.png" type="image/png" />
  <link rel="shortcut icon" href="favicon.png" type="image/png" />
  <link rel="apple-touch-icon" href="favicon.png" />
  <link rel="stylesheet" href="styles/reader.css" />
  <style>
    .loading-status {
      margin-top: 12px;
      font-size: 14px;
      color: var(--muted, #888);
      text-align: center;
    }
  </style>
  <!-- JSZip 库 - 多个备用 CDN -->
  <script>
    (function loadJSZip() {
      const jszipCDNs = [
        'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js',
        'https://unpkg.com/jszip@3.1.5/dist/jszip.min.js',
        'https://cdn.jsdelivr.net/npm/jszip@3.1.5/dist/jszip.min.js',
        'scripts/jszip.min.js', 
        'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js'
      ];
      
      
      function tryLoadJSZip(index = 0) {
        if (index >= jszipCDNs.length) {
          console.error('所有 JSZip CDN 都加载失败');
          return;
        }
        
        const script = document.createElement('script');
        script.src = jszipCDNs[index];
        script.onload = () => {
          console.log('JSZip 加载成功:', jszipCDNs[index]);
          loadEPUBjs(); // JSZip 加载成功后加载 EPUB.js
        };
        script.onerror = () => {
          console.warn('JSZip CDN 加载失败:', jszipCDNs[index]);
          tryLoadJSZip(index + 1); // 尝试下一个 CDN
        };
        document.head.appendChild(script);
      }
      
      function loadEPUBjs() {
        const epubCDNs = [
          'https://unpkg.com/epubjs/dist/epub.min.js',
          'https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js',
          'scripts/epub.min.js', 
          'https://unpkg.com/epubjs/dist/epub.min.js',  
        ];
        
        function tryLoadEPUBjs(index = 0) {
          if (index >= epubCDNs.length) {
            console.error('所有 EPUB.js CDN 都加载失败');
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').textContent = 'EPUB.js 库加载失败，请检查网络连接或刷新页面重试。';
            document.getElementById('reader-card').style.display = 'none';
            return;
          }
          
          const script = document.createElement('script');
          script.src = epubCDNs[index];
          script.onload = () => {
            console.log('EPUB.js 加载成功:', epubCDNs[index]);
            // 库加载完成后，检查是否可以直接初始化
            if (typeof ePub !== 'undefined') {
              console.log('EPUB.js 库已准备就绪');
            }
          };
          script.onerror = () => {
            console.warn('EPUB.js CDN 加载失败:', epubCDNs[index]);
            tryLoadEPUBjs(index + 1); // 尝试下一个 CDN
          };
          document.head.appendChild(script);
        }
        
        tryLoadEPUBjs();
      }
      
      // 开始加载 JSZip
      tryLoadJSZip();
    })();
  </script>
</head>
<body>
  <div class="container collapsed" id="layout-root">
    
    <!-- NOTE: .topbar 元素已被移动到下方的 #info-card 内部 -->

    <!-- 信息卡 (方案 C) -->
    <div id="info-card">
      <div class="line1">
        <button class="info-back" id="info-back-btn" title="返回上一页">←</button>
        <button id="toc-quick-btn" class="info-toc" title="目录">
          <span style="display:block; line-height:0;">
            <span style="display:block; width:16px; height:2px; background:#888; margin:3px 0; border-radius:2px;"></span>
            <span style="display:block; width:16px; height:2px; background:#888; margin:3px 0; border-radius:2px;"></span>
            <span style="display:block; width:16px; height:2px; background:#888; margin:3px 0; border-radius:2px;"></span>
          </span>
        </button>
        <button id="topbar-toggle" class="info-toggle" title="顶栏">⋯</button>
                 <span class="name" id="info-name">—</span>
         <button class="download-btn" id="download-btn" title="下载电子书到本地">⬇</button>
      </div>

      <!-- MODIFIED: .topbar 移动到这里，作为 #info-card 的子元素 -->
      <div class="topbar">
        <div class="left">
          <button class="back icon-btn" id="topbar-back-btn" title="返回上一页">←</button>
          <div class="meta title-ellipsis" id="book-meta" title="">正在加载…</div>
        </div>
        <div class="right controls">
          <div id="cover-mini" class="btn" style="display:none; gap:6px; align-items:center;" title="封面与信息 (I)">
            <span class="cover-box"></span>
            封面
          </div>
          <button id="bm-btn" class="btn" title="书签 (B)">🔖 书签</button>
          <button id="add-bm" class="btn" title="添加当前页为书签">＋ 书签</button>
          <div class="sep"></div>
          <button id="font-dec" class="btn" title="减小字号 (Alt+-)">A-</button>
          <button id="font-inc" class="btn" title="增大字号 (Alt+=)">A+</button>
          <select id="theme" class="select" title="阅读主题">
            <option value="day">日间</option>
            <option value="sepia">护眼</option>
            <option value="gray">灰色</option>
            <option value="night">夜间</option>
          </select>
          <button id="toggle-site-theme" class="btn" title="站点主题 (Alt+D)">🌓</button>
          <button id="help-btn" class="btn" title="帮助 (H)">❓</button>
        </div>
      </div>
    </div>

    <div class="progress">
      <input id="slider" class="range" type="range" min="0" max="1000" step="1" value="0" />
      <div id="percent" class="percent">0%</div>
    </div>

         <!-- 选区操作（高亮/复制/添加注释） -->
     <div id="selbar" class="controls">
       <span>标注：</span>
       <button data-color="hl-yellow" class="hl-chip hl-yellow">黄色</button>
       <button data-color="hl-green" class="hl-chip hl-green">绿色</button>
       <button data-color="hl-pink" class="hl-chip hl-pink">粉色</button>
       <div class="sep"></div>
       <button id="copy-selection" class="btn">复制选中</button>
       <button id="clear-highlights" class="btn">清除本章标注</button>
     </div>

     <!-- 下载状态显示 -->
     <div id="download-status" class="card" style="display: none; margin-bottom: 16px; padding: 20px; text-align: center;">
       <div id="download-cover" style="width: 200px; height: 280px; margin: 0 auto 20px; background: linear-gradient(135deg, #8B4513 0%, #A0522D 50%, #CD853F 100%); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: white; font-size: 24px; font-weight: bold;">
         <span id="cover-text">EP</span>
       </div>
       <h3 id="download-title" style="margin: 0 0 16px; color: var(--text);">正在加载电子书...</h3>
       <div id="download-progress-container" style="width: 100%; max-width: 400px; margin: 0 auto;">
         <div id="download-progress-bar" style="width: 100%; height: 8px; background: rgba(0,0,0,0.1); border-radius: 4px; overflow: hidden; margin-bottom: 12px;">
           <div id="download-progress-fill" style="width: 0%; height: 100%; background: #10b981; border-radius: 4px; transition: width 0.3s ease; position: relative;"></div>
         </div>
         <div id="download-progress-text" style="color: var(--muted); font-size: 14px;">准备下载...</div>
       </div>
     </div>

     <div class="card" id="reader-card">
      <div id="viewer-container">
        <div id="viewer"></div>
        <div id="reader-skeleton" aria-hidden="true">
          <div class="loading-content">
            <div class="loading-indicator">正在加载电子书，请稍候…</div>
            <div class="loading-progress-bar">
              <div class="loading-progress-fill"></div>
            </div>
            <div id="loading-status-text" class="loading-status">正在初始化...</div>
          </div>
        </div>
        <div id="nav">
          <div id="prev">‹</div>
          <div id="next">›</div>
        </div>
      </div>
    </div>

    <div id="error" class="error"></div>

    <!-- 目录抽屉 -->
    <aside id="drawer-toc" class="drawer">
      <h3>目录</h3>
      <ul id="toc" class="toc-list"></ul>
    </aside>

    <!-- 书签抽屉 -->
    <aside id="drawer-bm" class="drawer">
      <h3>我的书签</h3>
      <ul id="bm-list" class="bm-list"></ul>
      <div class="muted">点击书签可跳转，或删除。</div>

      <h3 style="margin-top:12px;">全文搜索</h3>
      <div class="controls" style="padding:8px;">
        <input id="fulltext-input" class="select" placeholder="输入关键词并回车…" />
      </div>
      <ul id="search-results"></ul>
    </aside>

    <!-- 信息抽屉在上方已定义 -->

    <!-- 遮罩：点击可关闭抽屉 -->
    <div id="overlay"></div>

    <!-- 封面与元数据抽屉 -->
    <aside id="drawer-info" class="drawer">
      <h3>封面与信息</h3>
      <img id="info-cover" class="cover-large" alt="封面预览"/>
      <dl id="info-meta" class="meta-table"></dl>
    </aside>
  </div>

  <script>
    // 站点主题：与首页保持一致
    (function initSiteTheme(){
      const key = 'site:theme';
      const saved = localStorage.getItem(key);
      if (saved) document.body.classList.toggle('dark', saved === 'dark');
      else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) document.body.classList.add('dark');
      const btn = document.getElementById('toggle-site-theme');
      if (btn) {
        btn.addEventListener('click', ()=>{
          const dark = !document.body.classList.contains('dark');
          document.body.classList.toggle('dark', dark);
          localStorage.setItem(key, dark ? 'dark' : 'light');
        });
      }
    })();

    function getQueryParam(name) {
      const url = new URL(window.location.href);
      const value = url.searchParams.get(name);
      return value ? decodeURIComponent(value) : null;
    }

    const bookPath = getQueryParam('book');
    const errorEl = document.getElementById('error');
    const metaEl = document.getElementById('book-meta');
    const percentEl = document.getElementById('percent');
    const sliderEl = document.getElementById('slider');

    const drawerToc = document.getElementById('drawer-toc');
    const drawerBm = document.getElementById('drawer-bm');
    const drawerInfo = document.getElementById('drawer-info');
    const tocList = document.getElementById('toc');
    const bmList = document.getElementById('bm-list');
    const infoCoverEl = document.getElementById('info-cover');
    const infoMetaEl = document.getElementById('info-meta');

    const storageKeys = {
      location: (p) => 'reader:lastLocation:' + p,
      font: (p) => 'reader:fontSize:' + p,
      theme: (p) => 'reader:theme:' + p,
      bookmarks: (p) => 'reader:bookmarks:' + p,
    };

    function safeLoad(key, fallback=null) {
      try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; } catch { return fallback; }
    }
    function safeSave(key, value) {
      try { localStorage.setItem(key, JSON.stringify(value)); } catch {}
    }

    let book, rendition, locationsReady = false;

    if (!bookPath) {
      errorEl.style.display = 'block';
      errorEl.textContent = '未指定要阅读的书籍。请从首页选择一本书。';
      document.getElementById('reader-card').style.display = 'none';
    } else {
      // 检查下载状态
      const downloadKey = `download:${bookPath}`;
      const downloadStatus = localStorage.getItem(downloadKey);
      const isDownloaded = downloadStatus && JSON.parse(downloadStatus).completed;
      
      // 如果未下载，显示下载界面
      if (!isDownloaded) {
        showDownloadInterface();
        startDownloadProcess();
      } else {
        // 已下载，直接加载电子书
        loadEbook();
      }
      
      function showDownloadInterface() {
        document.getElementById('download-status').style.display = 'block';
        document.getElementById('reader-card').style.display = 'none';
        
        // 设置书名
        const fileName = bookPath.split('/').pop().replace('.epub', '');
        document.getElementById('download-title').textContent = fileName;
      }
      
      function startDownloadProcess() {
        // 尝试加载封面
        loadCoverForDownload();
        
        // 模拟下载进度
        let progress = 0;
        const progressFill = document.getElementById('download-progress-fill');
        const progressText = document.getElementById('download-progress-text');
        
        const interval = setInterval(() => {
          progress += Math.random() * 15 + 5; // 随机增加5-20%
          if (progress >= 100) {
            progress = 100;
            clearInterval(interval);
            
            // 下载完成
            progressText.textContent = '下载完成！正在打开电子书...';
            progressFill.style.width = '100%';
            
            // 保存下载状态
            localStorage.setItem(downloadKey, JSON.stringify({
              completed: true,
              completedAt: Date.now()
            }));
            
            // 延迟后隐藏下载界面，显示阅读器
            setTimeout(() => {
              document.getElementById('download-status').style.display = 'none';
              document.getElementById('reader-card').style.display = 'block';
              loadEbook();
            }, 1500);
          } else {
            progressText.textContent = `下载中 ${Math.round(progress)}%`;
            progressFill.style.width = progress + '%';
          }
        }, 200 + Math.random() * 300); // 随机间隔200-500ms
      }
      
      async function loadCoverForDownload() {
        try {
          // 简单检查：如果 ePub 函数不存在，等待一下再试
          if (typeof ePub === 'undefined') {
            setTimeout(loadCoverForDownload, 100);
            return;
          }
          
          const book = ePub(bookPath);
          const coverEl = document.getElementById('download-cover');
          const coverText = document.getElementById('cover-text');
          
          // 优先尝试官方 API
          if (typeof book.coverUrl === 'function') {
            const url = await book.coverUrl();
            if (url) {
              coverEl.style.backgroundImage = `url('${url}')`;
              coverText.style.display = 'none';
              return;
            }
          }
          
          // 退化：从 metadata.cover 获取资源
          const meta = await book.loaded.metadata;
          const coverId = meta && (meta.cover || meta.cover_id || meta['cover-id']);
          if (coverId && book.archive && typeof book.archive.get === 'function') {
            const blob = await book.archive.get(coverId);
            if (blob) {
              const dataUrl = await blobToDataURL(blob);
              coverEl.style.backgroundImage = `url('${dataUrl}')`;
              coverText.style.display = 'none';
              return;
            }
          }
        } catch(e) { 
          // 忽略错误，使用默认封面
        }
      }
      
      function blobToDataURL(blob) {
        return new Promise((res) => {
          const r = new FileReader();
          r.onload = () => res(r.result);
          r.readAsDataURL(blob);
        });
      }
      
      // 全局变量，供所有函数使用
      
      function loadEbook() {
        // 简单检查：如果 ePub 函数不存在，等待一下再试
        if (typeof ePub === 'undefined') {
          setTimeout(loadEbook, 100);
          return;
        }
        
        let currentFont = safeLoad(storageKeys.font(bookPath), 100) || 100;
        const storedTheme = safeLoad(storageKeys.theme(bookPath), null);
        let currentTheme = storedTheme || 'gray';

        const skeleton = document.getElementById('reader-skeleton');
        const progressFill = skeleton.querySelector('.loading-progress-fill');

        function updateLoadingProgress(percentage) {
          if (progressFill) {
            progressFill.style.width = `${percentage}%`;
          }
        }

        try {
          updateLoadingProgress(0);
          if (skeleton) skeleton.classList.add('visible');
          
          book = ePub(bookPath);
          updateLoadingProgress(15);

          rendition = book.renderTo('viewer', { width: '100%', height: '100%' });
          updateLoadingProgress(30);

        // 自适应高度：让阅读区域填满剩余视口，避免底端留白
        const viewerContainer = document.getElementById('viewer-container');
        function resizeViewer(){
          try {
            const rect = viewerContainer.getBoundingClientRect();
            const gap = 16; // 页面底部预留
            const h = Math.max(320, Math.floor(window.innerHeight - rect.top - gap));
            viewerContainer.style.height = h + 'px';
          } catch {}
        }
        window.addEventListener('resize', resizeViewer);
        // 初次与异步渲染后多次校准
        setTimeout(resizeViewer, 0);

        // 主题 & 字体
        rendition.themes.register('day', {
          body: { background: '#ffffff !important', color: '#222222 !important' },
          '::selection': { background: '#cce5ff' }
        });
        rendition.themes.register('sepia', {
          body: { background: '#f4ecd8 !important', color: '#5b4636 !important' }
        });
        rendition.themes.register('gray', {
          body: { background: '#F5F5F5 !important', color: '#333333 !important' }
        });
        rendition.themes.register('night', {
          body: { background: '#0e0f12 !important', color: '#e2e2e2 !important' },
          a: { color: '#7ab6ff !important' }
        });
        rendition.themes.fontSize(currentFont + '%');
        rendition.themes.select(currentTheme);

        // 加载 + 骨架
        const savedLoc = safeLoad(storageKeys.location(bookPath));
        const displayPromise = savedLoc?.cfi 
          ? rendition.display(savedLoc.cfi) 
          : rendition.display();
        
        displayPromise.catch(() => {
          // 如果CFI加载失败，尝试无参数display
          return rendition.display();
        }).finally(() => { 
          updateLoadingProgress(100);
          setTimeout(() => {
            if (skeleton) skeleton.classList.remove('visible'); 
          }, 300);
        });

        // 元数据
        book.loaded.metadata.then(meta => {
          updateLoadingProgress(40);
          const title = meta?.title || '未命名书籍';
          const author = meta?.creator || meta?.author || '';
          metaEl.textContent = author ? `${title} — ${author}` : title;
          metaEl.title = title + (author ? ` — ${author}` : '');
          document.title = title + ' | 阅读电子书';
          // 更新信息卡
          const nameEl = document.getElementById('info-name');
          if (nameEl) {
            // 组合显示书名和作者
            const displayText = author ? `${title}(${author})` : title;
            const fullText = author ? `${title}(${author})` : title;
            
            nameEl.textContent = displayText;
            nameEl.title = fullText; // 悬停时显示完整内容
          }
        }).catch(() => { 
          metaEl.textContent = bookPath.split('/').pop(); 
          metaEl.title = metaEl.textContent; 
          
          // 错误情况下也更新顶栏标题
          const nameEl = document.getElementById('info-name');
          if (nameEl) {
            const fileName = bookPath.split('/').pop();
            nameEl.textContent = fileName;
            nameEl.title = fileName;
          }
        });

        // 封面缩略（阅读页顶栏）
        (async () => {
          const mini = document.getElementById('cover-mini');
          const box = mini ? mini.querySelector('.cover-box') : null;
          if (!mini || !box) return;
          try {
            await book.ready; // 确保打包信息可用
            // 1) 优先使用 API
            if (typeof book.coverUrl === 'function') {
              const url = await book.coverUrl();
              if (url) {
                box.style.backgroundImage = `url('${url}')`;
                const infoCoverEl = document.getElementById('info-cover');
                if (infoCoverEl) infoCoverEl.src = url;
                mini.style.display = 'inline-flex';
                try { const md = await book.loaded.metadata; fillInfoMeta(md); } catch {}
                return;
              }
            }
            // 2) EPUB3: manifest properties="cover-image"
            const packaging = book.packaging;
            let coverHref = null;
            if (packaging && packaging.manifest) {
              for (const id in packaging.manifest) {
                const it = packaging.manifest[id];
                const props = (it.properties || '').toString();
                if (props.includes('cover-image')) { coverHref = it.href; break; }
              }
              // 3) EPUB2: metadata.cover 指向 manifest id
              if (!coverHref && packaging.metadata && packaging.metadata.cover) {
                const id = packaging.metadata.cover;
                const it = packaging.manifest[id];
                if (it && it.href) coverHref = it.href;
              }
            }
            if (coverHref && book.archive && typeof book.archive.get === 'function') {
              const blob = await book.archive.get(coverHref);
              if (blob) {
                const url = URL.createObjectURL(blob);
                box.style.backgroundImage = `url('${url}')`;
                const infoCoverEl = document.getElementById('info-cover');
                if (infoCoverEl) infoCoverEl.src = url;
                mini.style.display = 'inline-flex';
                try { const md = await book.loaded.metadata; fillInfoMeta(md); } catch {}
                return;
              }
            }
          } catch {/* 忽略 */}
        })();

        function fillInfoMeta(md){
          const infoMetaEl = document.getElementById('info-meta');
          if (!infoMetaEl || !md) return;
          infoMetaEl.innerHTML = '';
          const rows = [
            ['标题', md.title],
            ['作者', md.creator || md.author],
            ['出版社', md.publisher],
            ['语言', md.language],
            ['出版时间', md.published || md.date],
            ['标识符', md.identifier],
          ].filter(([,v]) => !!v);
          for (const [k,v] of rows){
            const dt = document.createElement('dt'); dt.textContent = k;
            const dd = document.createElement('dd'); dd.textContent = Array.isArray(v) ? v.join(', ') : String(v);
            infoMetaEl.appendChild(dt); infoMetaEl.appendChild(dd);
          }
        }

        // 目录
        book.loaded.navigation.then(({ toc }) => {
          updateLoadingProgress(60);
          renderTOC(toc || []);
        }).catch(() => { /* 忽略 */ });

        // 生成 locations 用于进度
        book.ready.then(() => book.locations.generate(1600)).then(() => {
          updateLoadingProgress(85);
          locationsReady = true;
          const loc = rendition.currentLocation();
          updateProgress(loc);
        }).catch(() => { locationsReady = false; });

        // 事件：翻页
        document.getElementById('prev').addEventListener('click', () => rendition.prev());
        document.getElementById('next').addEventListener('click', () => rendition.next());
        document.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowLeft') rendition.prev();
          if (e.key === 'ArrowRight') rendition.next();
          if (e.key.toLowerCase() === 'i') document.getElementById('cover-mini').click();
          if ((e.altKey && (e.key === '-' || e.key === '_'))) document.getElementById('font-dec').click();
          if ((e.altKey && (e.key === '=' || e.key === '+'))) document.getElementById('font-inc').click();
          if (e.key.toLowerCase() === 't') document.getElementById('toc-quick-btn').click();
          if (e.key.toLowerCase() === 'b') document.getElementById('bm-btn').click();
          if (e.key.toLowerCase() === 'h') document.getElementById('help-btn').click();
          if (e.altKey && (e.key.toLowerCase() === 'd')) document.getElementById('toggle-site-theme').click();
        });

        // 事件：位置变更 -> 更新进度 & 保存
        rendition.on('relocated', (location) => {
          updateProgress(location);
          // 保存最后阅读位置
          safeSave(storageKeys.location(bookPath), {
            cfi: location?.start?.cfi || location?.end?.cfi || null,
            percentage: getPercentageFromLocation(location),
            updatedAt: Date.now()
          });
          const pct = getPercentageFromLocation(location);
          const prog = document.getElementById('info-progress');
          if (prog && (pct || pct===0)) prog.textContent = `进度 ${Math.round(pct*100)}%`;
        });

        // 字体
        document.getElementById('font-inc').addEventListener('click', () => {
          currentFont = Math.min(180, currentFont + 10);
          rendition.themes.fontSize(currentFont + '%');
          safeSave(storageKeys.font(bookPath), currentFont);
        });
        document.getElementById('font-dec').addEventListener('click', () => {
          currentFont = Math.max(80, currentFont - 10);
          rendition.themes.fontSize(currentFont + '%');
          safeSave(storageKeys.font(bookPath), currentFont);
        });

        // 主题
        const themeSelect = document.getElementById('theme');
        themeSelect.value = currentTheme;
        themeSelect.addEventListener('change', () => {
          currentTheme = themeSelect.value;
          rendition.themes.select(currentTheme);
          // 强制刷新当前视图，避免主题被书内样式覆盖或延迟应用
          const loc = rendition.currentLocation();
          if (loc?.start?.cfi) rendition.display(loc.start.cfi);
          safeSave(storageKeys.theme(bookPath), currentTheme);
        });

        // 设置根容器样式
        const root = document.getElementById('layout-root');

        // 折叠/展开顶栏
        const toggleBtn = document.getElementById('topbar-toggle');
        const COLLAPSE_KEY = 'reader:topbar:collapsed';
        if (toggleBtn) {
          toggleBtn.addEventListener('click', ()=>{
            const collapsed = root.classList.toggle('collapsed');
            localStorage.setItem(COLLAPSE_KEY, String(collapsed));
          });
        }

        // 点击页面自动收起顶栏（排除顶栏/信息卡/抽屉/帮助弹窗区域）
        function collapseTopbar(){
          if (!root.classList.contains('collapsed')) {
            root.classList.add('collapsed');
            localStorage.setItem(COLLAPSE_KEY, 'true');
          }
        }
        
        document.addEventListener('click', (e)=>{
          const t = e.target;
          if (t.closest('.topbar') || t.closest('#info-card') || t.closest('.drawer') || t.closest('#help-modal')) return;
          collapseTopbar();
        }, { capture: true });
        // 收起顶栏：内容区点击（iframe 内） & 移动端滑动翻页
        rendition.on('rendered', (_section, view) => {
          try { 
            view.document.addEventListener('click', collapseTopbar, { capture: true }); 

            // 滑动翻页逻辑
            let touchstartX = 0;
            let touchendX = 0;
            let touchstartY = 0;
            let touchendY = 0;
            const swipeThreshold = 50; // 最小滑动距离
            const swipeYThreshold = 100; // Y轴最大容忍滑动距离

            view.document.addEventListener('touchstart', e => {
              touchstartX = e.changedTouches[0].screenX;
              touchstartY = e.changedTouches[0].screenY;
            }, { passive: true });

            view.document.addEventListener('touchend', e => {
              touchendX = e.changedTouches[0].screenX;
              touchendY = e.changedTouches[0].screenY;
              
              const deltaX = touchendX - touchstartX;
              const deltaY = touchendY - touchstartY;

              // 检查是否为有效的水平滑动
              if (Math.abs(deltaX) > swipeThreshold && Math.abs(deltaY) < swipeYThreshold) {
                if (deltaX < 0) { // 向左滑
                  rendition.next();
                } else { // 向右滑
                  rendition.prev();
                }
              }
            }, { passive: true });

            // 鼠标滚轮翻页逻辑
            let wheelTimeout = null;
            const wheelThreshold = 50; // 滚轮滚动阈值
            let wheelDelta = 0;

            view.document.addEventListener('wheel', e => {
              // 阻止默认滚动行为
              e.preventDefault();
              
              // 累积滚轮增量
              wheelDelta += e.deltaY;
              
              // 清除之前的定时器
              if (wheelTimeout) {
                clearTimeout(wheelTimeout);
              }
              
              // 设置延迟执行，避免快速滚动时频繁翻页
              wheelTimeout = setTimeout(() => {
                if (Math.abs(wheelDelta) >= wheelThreshold) {
                  if (wheelDelta > 0) {
                    // 向下滚动，翻到下一页
                    rendition.next();
                  } else {
                    // 向上滚动，翻到上一页
                    rendition.prev();
                  }
                  // 重置滚轮增量
                  wheelDelta = 0;
                }
              }, 150); // 150ms 延迟，平衡响应性和稳定性
            }, { passive: false });

          } catch {}
        });
        // 默认不再强制跟随站点主题，避免覆盖用户选择

        // 进度滑块
        sliderEl.addEventListener('input', (e) => {
          const pct = (Number(e.target.value) || 0) / 1000;
          percentEl.textContent = Math.round(pct * 100) + '%';
        });
        sliderEl.addEventListener('change', (e) => {
          if (!locationsReady) return;
          const pct = (Number(e.target.value) || 0) / 1000;
          try {
            const cfi = book.locations.cfiFromPercentage(pct);
            if (cfi) rendition.display(cfi);
          } catch {}
        });

        // 目录抽屉 & 书签抽屉 & 信息抽屉
        const overlay = document.getElementById('overlay');
        function openDrawer(which){
          drawerToc.classList.toggle('open', which==='toc');
          drawerBm.classList.toggle('open', which==='bm');
          drawerInfo.classList.toggle('open', which==='info');
          const anyOpen = which==='toc' || which==='bm' || which==='info';
          overlay.style.display = anyOpen ? 'block' : 'none';
        }
        function closeDrawers(){ openDrawer(null); }

        // 返回按钮事件监听器
        function handleBackClick() {
          if (window.history.length > 1) {
            window.history.back();
          } else {
            // 如果没有历史记录，回退到书库
            window.location.href = 'index.html';
          }
        }
        
        document.getElementById('info-back-btn').addEventListener('click', handleBackClick);
        document.getElementById('topbar-back-btn').addEventListener('click', handleBackClick);

        // 快捷目录按钮事件监听器
        document.getElementById('toc-quick-btn').addEventListener('click', () => {
          openDrawer(drawerToc.classList.contains('open') ? null : 'toc');
        });
        document.getElementById('bm-btn').addEventListener('click', () => {
          openDrawer(drawerBm.classList.contains('open') ? null : 'bm');
        });
        document.getElementById('cover-mini').addEventListener('click', () => {
          openDrawer(drawerInfo.classList.contains('open') ? null : 'info');
        });
        overlay.addEventListener('click', closeDrawers);
        // ESC 关闭抽屉
        document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeDrawers(); });

        // 添加书签
        document.getElementById('add-bm').addEventListener('click', () => {
          const loc = rendition.currentLocation();
          const cfi = loc?.start?.cfi || loc?.end?.cfi;
          if (!cfi) return;
          const pct = getPercentageFromLocation(loc);
          const tocItem = findTocItemForCfi(book, loc?.start?.cfi);
          const label = (tocItem?.label || '当前位置') + ' · ' + Math.round((pct || 0) * 100) + '%';
          const list = safeLoad(storageKeys.bookmarks(bookPath), []);
          // 去重
          if (!list.some(b => b.cfi === cfi)) {
            list.push({ cfi, label, createdAt: Date.now() });
            safeSave(storageKeys.bookmarks(bookPath), list);
            renderBookmarks(list);
            drawerBm.classList.add('open');
          }
        });

                 // 首次渲染书签
         renderBookmarks(safeLoad(storageKeys.bookmarks(bookPath), []));
         
         // 下载按钮功能
         const downloadBtn = document.getElementById('download-btn');
         if (downloadBtn) {
           downloadBtn.addEventListener('click', async () => {
             try {
               // 显示下载中状态
               downloadBtn.textContent = '⏳';
               downloadBtn.disabled = true;
               
               // 获取电子书数据 - 使用正确的方法
               let bookData;
               if (book.archive && typeof book.archive.get === 'function') {
                 // 如果 archive.get 方法存在，使用它
                 bookData = await book.archive.get();
               } else if (book.archive && book.archive.url) {
                 // 如果 archive.url 存在，直接使用
                 bookData = book.archive.url;
               } else {
                 // 尝试从原始路径获取
                 const response = await fetch(bookPath);
                 if (!response.ok) {
                   throw new Error('无法获取电子书数据');
                 }
                 bookData = await response.blob();
               }
               
               if (!bookData) {
                 throw new Error('无法获取电子书数据');
               }
               
               // 创建下载链接
               let blob;
               if (bookData instanceof Blob) {
                 blob = bookData;
               } else if (typeof bookData === 'string') {
                 // 如果是 URL，需要先获取数据
                 const response = await fetch(bookData);
                 blob = await response.blob();
               } else {
                 throw new Error('不支持的电子书数据格式');
               }
               
               const url = URL.createObjectURL(blob);
               const a = document.createElement('a');
               a.href = url;
               a.download = bookPath.split('/').pop() || 'book.epub';
               document.body.appendChild(a);
               a.click();
               document.body.removeChild(a);
               
               // 清理URL对象
               URL.revokeObjectURL(url);
               
               // 恢复按钮状态
               downloadBtn.textContent = '✅';
               setTimeout(() => {
                 downloadBtn.textContent = '⬇';
                 downloadBtn.disabled = false;
               }, 2000);
               
             } catch (error) {
               console.error('下载失败:', error);
               downloadBtn.textContent = '❌';
               setTimeout(() => {
                 downloadBtn.textContent = '⬇';
                 downloadBtn.disabled = false;
               }, 2000);
             }
           });
         }

      } catch (err) {
        errorEl.style.display = 'block';
        errorEl.textContent = '加载电子书失败：' + (err?.message || err);
        document.getElementById('reader-card').style.display = 'none';
      }
    }

    // Service Worker 注册（需 http/https 环境，file:// 无效）
    // 用于部署“自杀式”worker，清理旧的worker
    if ('serviceWorker' in navigator && location.protocol !== 'file:') {
      navigator.serviceWorker.register('sw.js').catch((err) => {
        console.error('Service Worker registration failed:', err);
      });
    }

    // 辅助函数定义
    function renderTOC(toc) {
        tocList.innerHTML = '';
        if (!toc || !toc.length) {
          const li = document.createElement('li');
          li.className = 'toc-item muted';
          li.textContent = '无目录';
          tocList.appendChild(li);
          return;
        }
        const flat = flattenToc(toc);
        flat.forEach(item => {
          const li = document.createElement('li');
          li.className = 'toc-item';
          li.style.paddingLeft = (item.depth * 12 + 6) + 'px';
          li.textContent = item.label || item.href;
          li.title = item.label || item.href;
          li.addEventListener('click', () => {
            rendition.display(item.href);
            drawerToc.classList.remove('open');
          });
          tocList.appendChild(li);
        });
      }

      function flattenToc(nodes, depth=0, out=[]) {
        (nodes || []).forEach(n => {
          out.push({ label: n.label, href: n.href, depth });
          if (n.subitems && n.subitems.length) flattenToc(n.subitems, depth+1, out);
        });
        return out;
      }

      function renderBookmarks(list) {
        bmList.innerHTML = '';
        if (!list.length) {
          const li = document.createElement('li');
          li.className = 'bm-item muted';
          li.textContent = '暂无书签';
          bmList.appendChild(li);
          return;
        }
        list.forEach((b, idx) => {
          const li = document.createElement('li');
          li.className = 'bm-item';
          const row = document.createElement('div');
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.justifyContent = 'space-between';
          row.style.gap = '8px';
          const title = document.createElement('div');
          title.textContent = b.label || ('书签 ' + (idx+1));
          const actions = document.createElement('div');
          actions.className = 'bm-actions';
          const go = document.createElement('button'); go.className = 'btn'; go.textContent = '前往';
          const del = document.createElement('button'); del.className = 'btn'; del.textContent = '删除';
          go.addEventListener('click', () => { rendition.display(b.cfi); drawerBm.classList.remove('open'); });
          del.addEventListener('click', () => {
            const arr = safeLoad(storageKeys.bookmarks(bookPath), []);
            const next = arr.filter(x => x.cfi !== b.cfi);
            safeSave(storageKeys.bookmarks(bookPath), next);
            renderBookmarks(next);
          });
          actions.appendChild(go); actions.appendChild(del);
          row.appendChild(title); row.appendChild(actions);
          li.appendChild(row);
          bmList.appendChild(li);
        });
      }

      function getPercentageFromLocation(location) {
        try {
          if (!location) return 0;
          const cfi = location?.start?.cfi || location?.end?.cfi;
          if (!cfi || !book.locations) return 0;
          if (!locationsReady) return 0;
          return book.locations.percentageFromCfi(cfi) || 0;
        } catch { return 0; }
      }

      function updateProgress(location) {
        if (!locationsReady || !location || !location.start) return;

        try {
          const cfi = location.start.cfi;
          const currentPage = book.locations.locationFromCfi(cfi);
          const totalPages = book.locations.total;
          
          if (currentPage > 0 && totalPages) {
            percentEl.textContent = `${currentPage} / ${totalPages}`;
          } else if (totalPages) {
            percentEl.textContent = `共 ${totalPages} 页`;
          } else {
            const pct = getPercentageFromLocation(location);
            percentEl.textContent = Math.round(pct * 100) + '%';
          }
          
          const pct = getPercentageFromLocation(location);
          if (pct || pct === 0) {
            sliderEl.value = Math.round(pct * 1000);
          }
        } catch (e) {
          // Fallback to percentage if page calculation fails
          const pct = getPercentageFromLocation(location);
          percentEl.textContent = Math.round(pct * 100) + '%';
        }
      }

      function findTocItemForCfi(book, cfi) {
        // 简化实现：返回当前可视章节名（如果可得）
        try {
          if (!cfi) return null;
          const nav = book.navigation || book.loaded?.navigation?.value;
          if (!nav || !nav.toc) return null;
          const flat = flattenToc(nav.toc);
          // 最简单策略：根据 href 片段匹配当前 spine href（epub.js 未提供直接 cfi -> href 的同步API）
          const loc = rendition.currentLocation();
          const href = loc?.start?.href;
          if (!href) return null;
          return flat.find(i => (i.href || '').split('#')[0] === href.split('#')[0]) || null;
        } catch { return null; }
      }
    }
  </script>
  </script>

  <!-- 帮助弹窗 -->
  <div id="help-modal" class="modal" aria-modal="true" role="dialog">
    <div class="modal-card">
      <h3>快捷键与技巧</h3>
      <div>
        <p><span class="kbd">←</span> / <span class="kbd">→</span> 翻页 · 鼠标滚轮上下滚动翻页</p>
        <p><span class="kbd">Alt</span> + <span class="kbd">-</span> / <span class="kbd">Alt</span> + <span class="kbd">=</span> 调整字号</p>
        <p><span class="kbd">T</span> 打开/关闭目录 · <span class="kbd">B</span> 打开/关闭书签</p>
        <p><span class="kbd">H</span> 打开/关闭帮助 · <span class="kbd">Alt</span> + <span class="kbd">D</span> 切换站点主题</p>
        <p>拖动进度条可快速定位 · 顶栏采用毛玻璃效果增强可读性</p>
      </div>
      <div style="margin-top:10px; display:flex; justify-content:flex-end; gap:8px;">
        <button id="help-close" class="btn">关闭</button>
      </div>
    </div>
  </div>

  <script>
    (function helpModalInit(){
      const modal = document.getElementById('help-modal');
      const openBtn = document.getElementById('help-btn');
      const closeBtn = document.getElementById('help-close');
      const toggle = () => modal.classList.toggle('open');
      if (openBtn) openBtn.addEventListener('click', toggle);
      if (closeBtn) closeBtn.addEventListener('click', toggle);
      modal.addEventListener('click', (e) => { if (e.target === modal) toggle(); });
    })();
  </script>
</body>
</html>